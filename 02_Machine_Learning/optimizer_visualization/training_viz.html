<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Optimizer Comparison Visualization</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            color: #2c3e50;
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 2.5rem;
            color: #2c3e50;
        }
        .optimizer-panel {
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            margin: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }
        .optimizer-panel.enabled {
            border-color: #4a90e2;
            box-shadow: 0 4px 15px rgba(74, 144, 226, 0.3);
        }
        .optimizer-panel.disabled {
            opacity: 0.6;
            border-color: #ccc;
        }
        
        .gradient-control {
            grid-column: 1 / -1;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            margin: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        
        .gradient-checkbox-label {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-weight: 500;
            color: #3c4043;
            cursor: pointer;
        }
        
        .gradient-checkbox-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        .color-config-control {
            grid-column: 1 / -1;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            margin: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .logging-control {
            grid-column: 1 / -1;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            margin: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .logging-header {
            margin-bottom: 10px;
            text-align: center;
        }

        .logging-title {
            font-weight: 600;
            color: #3c4043;
            font-size: 0.9rem;
        }

        .logging-params {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .logging-param-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .logging-param-label {
            font-weight: 500;
            color: #3c4043;
            font-size: 0.85rem;
        }

        .logging-radio-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 8px;
        }

        .logging-radio-option {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 5px 8px;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid #dee2e6;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8rem;
        }

        .logging-radio-option:hover {
            background: rgba(74, 144, 226, 0.1);
            border-color: #4a90e2;
        }

        .logging-radio-option input[type="radio"] {
            margin: 0;
            transform: scale(0.9);
        }

        .logging-radio-option input[type="radio"]:checked + span {
            font-weight: 600;
            color: #4a90e2;
        }
        
        .color-config-header {
            margin-bottom: 10px;
            text-align: center;
        }
        
        .color-config-title {
            font-weight: 600;
            color: #3c4043;
            font-size: 0.9rem;
        }
        
        .color-config-params {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .color-param-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .color-param-label {
            color: #666;
            font-size: 0.8rem;
            font-weight: 500;
        }
        
        .color-config-control input[type="color"] {
            width: 100%;
            height: 35px;
            border: 1px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            background: none;
        }
        .optimizer-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .optimizer-checkbox {
            margin-right: 10px;
            transform: scale(1.2);
        }
        .optimizer-title {
            font-weight: bold;
            font-size: 1.1rem;
            margin-right: 15px;
        }
        .optimizer-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #333;
            margin-right: 10px;
        }
        .optimizer-params {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        .param-group {
            display: flex;
            flex-direction: column;
        }
        .param-label {
            font-size: 0.8rem;
            font-weight: bold;
            color: #666;
            margin-bottom: 2px;
        }
        .param-input {
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 0.9rem;
        }
        .comparison-controls {
            text-align: center;
            margin: 20px 0;
        }
        .optimizers-container {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            margin: 20px 0;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .optimizers-header {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .optimizers-header:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .optimizers-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: white;
            font-weight: 600;
            font-size: 1.1rem;
        }
        
        .toggle-icon {
            font-size: 1.2rem;
            transition: transform 0.3s ease;
            margin-right: 10px;
        }
        
        .optimizers-container.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }
        
        .optimizers-count {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .optimizer-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px;
            transition: all 0.3s ease;
            max-height: 1000px;
            overflow: hidden;
        }
        
        .optimizers-container.collapsed .optimizer-grid {
            max-height: 0;
            margin: 0 20px;
            padding: 0;
        }
        
        /* Functions Container Styles */
        .functions-container {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border-radius: 15px;
            margin: 20px 0;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .functions-header {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .functions-header:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .functions-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: white;
            font-weight: 600;
            font-size: 1.1rem;
        }
        
        .functions-count {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .functions-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin: 20px;
            transition: all 0.3s ease;
            max-height: 1000px;
            overflow: hidden;
        }
        
        .functions-container.collapsed .functions-grid {
            max-height: 0;
            margin: 0 20px;
            padding: 0;
        }
        
        .functions-container.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }
        
        /* Function Panel Styles */
        .function-panel {
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }
        
        .function-panel.enabled {
            border-color: #27ae60;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3);
            background: rgba(255, 255, 255, 0.95);
        }
        
        .function-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .function-radio {
            margin-right: 10px;
            transform: scale(1.2);
        }
        
        .function-title {
            font-weight: bold;
            font-size: 1.1rem;
            color: #2c3e50;
        }
        
        .function-formula {
            background: #f8f9fa;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            color: #495057;
            margin-bottom: 15px;
            border-left: 4px solid #27ae60;
        }
        
        .function-params {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .param-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .param-row span {
            font-weight: 500;
            color: #6c757d;
        }
        
        /* Views Container Styles */
        .views-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px auto;
            max-width: 1600px;
            padding: 0 20px;
        }
        
        .view-container {
            background: linear-gradient(135deg, #4a90e2 0%, #7bb3f0 100%);
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .view-header {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0.08) 100%);
            padding: 5px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 1px solid rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(10px);
        }
        
        .view-header:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.15) 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .view-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: white;
            font-weight: 600;
            font-size: 1.1rem;
        }
        
        .view-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .fullscreen-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            padding: 4px 6px;
            transition: all 0.2s ease;
        }
        
        .fullscreen-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }
        
        .view-label {
            flex: 1;
            margin-left: 10px;
        }
        
        .view-status {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .view-content {
            padding: 8px;
            text-align: center;
            position: relative;
        }
        
        .canvas-3d, .canvas-2d {
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }
        
        .mouse-coordinates {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        
        /* Fullscreen mode styles */
        .view-container.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 9999;
            border-radius: 0;
            margin: 0;
            max-width: none;
        }
        
        .view-container.fullscreen .view-content {
            height: calc(100vh - 40px);
            max-height: none;
            padding: 2px;
        }
        
        .view-container.fullscreen canvas {
            width: 100%;
            height: 100%;
            max-width: none;
            max-height: none;
        }
        
        .view-container.fullscreen .view-header {
            height: 40px;
            padding: 5px 20px;
        }
        
        .fullscreen-btn.active {
            background: rgba(255, 255, 255, 0.4);
            border-color: rgba(255, 255, 255, 0.6);
        }
        
        /* Compact Optimizer Controls in Header */
        .optimizer-controls-compact {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 4px 6px;
            margin-right: 8px;
        }
        
        .control-btn-compact {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 11px;
            padding: 2px 6px;
            transition: all 0.2s ease;
            min-width: 24px;
            height: 20px;
        }
        
        .control-btn-compact:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }
        
        /* Compact Zoom Controls in Header */
        .zoom-controls-compact {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 0 10px;
        }
        
        .zoom-btn-compact {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .zoom-btn-compact:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        .zoom-btn-compact:active {
            transform: scale(0.95);
        }
        
        .zoom-level-compact {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
            min-width: 40px;
            text-align: center;
        }
        select {
            background: linear-gradient(120deg, #4a90e2, #7bb3f0);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 10px 15px;
            margin: 5px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(74, 144, 226, 0.3);
        }
        select:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(74, 144, 226, 0.4);
        }
        .controls {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        button {
            background: linear-gradient(120deg, #4a90e2, #7bb3f0);
            color: white;
            border: none;
            font-weight: 700;
            letter-spacing: 0.5px;
            border-radius: 10px;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(74, 144, 226, 0.3);
        }
        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(74, 144, 226, 0.4);
        }
        .canvas-container {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        canvas {
            border: 2px solid #4a90e2;
            border-radius: 8px;
            background: #ffffff;
        }
        .info {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🏁 Neural Network Optimizer Training Visualization</h1>
        
        <div class="functions-container">
            <div class="functions-header" onclick="toggleFunctionsContainer()">
                <div class="functions-title">
                    <span class="toggle-icon" id="toggle-functions-icon">▼</span>
                    <span class="functions-label">📊 Function Selection & Parameters</span>
                    <span class="functions-count" id="functions-count">Himmelblau Function</span>
                </div>
            </div>
            <div class="functions-grid" id="functions-grid">
                <!-- Himmelblau Function -->
                <div class="function-panel enabled" id="himmelblau-panel">
                    <div class="function-header">
                        <input type="radio" class="function-radio" id="himmelblau-radio" name="function" value="himmelblau" onchange="changeFunction('himmelblau')" checked>
                        <div class="function-title">Himmelblau Function</div>
                    </div>
                    <div class="function-formula">
                        f(x,y) = (x² + y - 11)² + (x + y² - 7)²
                    </div>
                    <div class="function-params">
                        <div class="param-group">
                            <div class="param-label">X Range</div>
                            <div class="param-row">
                                <input type="number" class="param-input" id="himmelblau-xmin" value="-6" step="0.5">
                                <span>to</span>
                                <input type="number" class="param-input" id="himmelblau-xmax" value="6" step="0.5">
                            </div>
                        </div>
                        <div class="param-group">
                            <div class="param-label">Y Range</div>
                            <div class="param-row">
                                <input type="number" class="param-input" id="himmelblau-ymin" value="-6" step="0.5">
                                <span>to</span>
                                <input type="number" class="param-input" id="himmelblau-ymax" value="6" step="0.5">
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Rosenbrock Function -->
                <div class="function-panel" id="rosenbrock-panel">
                    <div class="function-header">
                        <input type="radio" class="function-radio" id="rosenbrock-radio" name="function" value="rosenbrock" onchange="changeFunction('rosenbrock')">
                        <div class="function-title">Rosenbrock Function</div>
                    </div>
                    <div class="function-formula">
                        f(x,y) = 100(y - x²)² + (1 - x)²
                    </div>
                    <div class="function-params">
                        <div class="param-group">
                            <div class="param-label">X Range</div>
                            <div class="param-row">
                                <input type="number" class="param-input" id="rosenbrock-xmin" value="-2" step="0.1">
                                <span>to</span>
                                <input type="number" class="param-input" id="rosenbrock-xmax" value="2" step="0.1">
                            </div>
                        </div>
                        <div class="param-group">
                            <div class="param-label">Y Range</div>
                            <div class="param-row">
                                <input type="number" class="param-input" id="rosenbrock-ymin" value="-1" step="0.1">
                                <span>to</span>
                                <input type="number" class="param-input" id="rosenbrock-ymax" value="3" step="0.1">
                            </div>
                        </div>
                    </div>
            </div>
            
                <!-- Quadratic Bowl Function -->
                <div class="function-panel" id="quadratic-panel">
                    <div class="function-header">
                        <input type="radio" class="function-radio" id="quadratic-radio" name="function" value="quadratic" onchange="changeFunction('quadratic')">
                        <div class="function-title">Quadratic Bowl</div>
                    </div>
                    <div class="function-formula">
                        f(x,y) = x² + y²
                    </div>
                    <div class="function-params">
                        <div class="param-group">
                            <div class="param-label">X Range</div>
                            <div class="param-row">
                                <input type="number" class="param-input" id="quadratic-xmin" value="-5" step="0.5">
                                <span>to</span>
                                <input type="number" class="param-input" id="quadratic-xmax" value="5" step="0.5">
                            </div>
                        </div>
                        <div class="param-group">
                            <div class="param-label">Y Range</div>
                            <div class="param-row">
                                <input type="number" class="param-input" id="quadratic-ymin" value="-5" step="0.5">
                                <span>to</span>
                                <input type="number" class="param-input" id="quadratic-ymax" value="5" step="0.5">
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Booth Function -->
                <div class="function-panel" id="booth-panel">
                    <div class="function-header">
                        <input type="radio" class="function-radio" id="booth-radio" name="function" value="booth" onchange="changeFunction('booth')">
                        <div class="function-title">Booth Function</div>
                    </div>
                    <div class="function-formula">
                        f(x,y) = (x + 2y - 7)² + (2x + y - 5)²
                    </div>
                    <div class="function-params">
                        <div class="param-group">
                            <div class="param-label">X Range</div>
                            <div class="param-row">
                                <input type="number" class="param-input" id="booth-xmin" value="-10" step="1">
                                <span>to</span>
                                <input type="number" class="param-input" id="booth-xmax" value="10" step="1">
                            </div>
                        </div>
                        <div class="param-group">
                            <div class="param-label">Y Range</div>
                            <div class="param-row">
                                <input type="number" class="param-input" id="booth-ymin" value="-10" step="1">
                                <span>to</span>
                                <input type="number" class="param-input" id="booth-ymax" value="10" step="1">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="optimizers-container">
            <div class="optimizers-header" onclick="toggleOptimizersContainer()">
                <div class="optimizers-title">
                    <span class="toggle-icon" id="toggle-icon">▼</span>
                    <span class="optimizers-label">Optimizers Control Panel</span>
                    <span class="optimizers-count" id="optimizers-count">6 enabled</span>
                </div>
            </div>
            <div class="optimizer-grid" id="optimizer-grid">
            <div class="optimizer-panel enabled" id="sgd-panel">
                <div class="optimizer-header">
                    <input type="checkbox" class="optimizer-checkbox" id="sgd-checkbox" checked onchange="toggleOptimizer('sgd')">
                    <div class="optimizer-color" style="background-color: #d32f2f;" id="sgd-color"></div>
                    <div class="optimizer-title">SGD</div>
                    <input type="color" id="sgd-color-picker" value="#d32f2f" onchange="changeOptimizerColor('sgd', this.value)">
                </div>
                <div class="optimizer-params">
                    <div class="param-group">
                        <div class="param-label">Learning Rate</div>
                        <input type="number" class="param-input" id="sgd-lr" value="0.002" step="0.0001" min="0.0001" max="1">
                    </div>
                </div>
            </div>
            
            <div class="optimizer-panel enabled" id="momentum-panel">
                <div class="optimizer-header">
                    <input type="checkbox" class="optimizer-checkbox" id="momentum-checkbox" checked onchange="toggleOptimizer('momentum')">
                    <div class="optimizer-color" style="background-color: #0288d1;" id="momentum-color"></div>
                    <div class="optimizer-title">Momentum</div>
                    <input type="color" id="momentum-color-picker" value="#0288d1" onchange="changeOptimizerColor('momentum', this.value)">
                </div>
                <div class="optimizer-params">
                    <div class="param-group">
                        <div class="param-label">Learning Rate</div>
                        <input type="number" class="param-input" id="momentum-lr" value="0.002" step="0.0001" min="0.0001" max="1">
                    </div>
                    <div class="param-group">
                        <div class="param-label">Beta</div>
                        <input type="number" class="param-input" id="momentum-beta" value="0.9" step="0.01" min="0" max="0.99">
                    </div>
                </div>
            </div>
            
            <div class="optimizer-panel enabled" id="adagrad-panel">
                <div class="optimizer-header">
                    <input type="checkbox" class="optimizer-checkbox" id="adagrad-checkbox" checked onchange="toggleOptimizer('adagrad')">
                    <div class="optimizer-color" style="background-color: #388e3c;" id="adagrad-color"></div>
                    <div class="optimizer-title">AdaGrad</div>
                    <input type="color" id="adagrad-color-picker" value="#388e3c" onchange="changeOptimizerColor('adagrad', this.value)">
                </div>
                <div class="optimizer-params">
                    <div class="param-group">
                        <div class="param-label">Learning Rate</div>
                        <input type="number" class="param-input" id="adagrad-lr" value="0.1" step="0.01" min="0.001" max="1">
                    </div>
                    <div class="param-group">
                        <div class="param-label">Epsilon</div>
                        <input type="number" class="param-input" id="adagrad-eps" value="1e-8" step="1e-9" min="1e-12" max="1e-6">
                    </div>
                </div>
            </div>
            
            <div class="optimizer-panel enabled" id="adam-panel">
                <div class="optimizer-header">
                    <input type="checkbox" class="optimizer-checkbox" id="adam-checkbox" checked onchange="toggleOptimizer('adam')">
                    <div class="optimizer-color" style="background-color: #f57c00;" id="adam-color"></div>
                    <div class="optimizer-title">Adam</div>
                    <input type="color" id="adam-color-picker" value="#f57c00" onchange="changeOptimizerColor('adam', this.value)">
                </div>
                <div class="optimizer-params">
                    <div class="param-group">
                        <div class="param-label">Learning Rate</div>
                        <input type="number" class="param-input" id="adam-lr" value="0.01" step="0.001" min="0.0001" max="1">
                    </div>
                    <div class="param-group">
                        <div class="param-label">Beta1</div>
                        <input type="number" class="param-input" id="adam-beta1" value="0.9" step="0.01" min="0" max="0.99">
                    </div>
                    <div class="param-group">
                        <div class="param-label">Beta2</div>
                        <input type="number" class="param-input" id="adam-beta2" value="0.999" step="0.001" min="0.9" max="0.9999">
                    </div>
                    <div class="param-group">
                        <div class="param-label">Epsilon</div>
                        <input type="number" class="param-input" id="adam-eps" value="1e-8" step="1e-9" min="1e-12" max="1e-6">
                    </div>
                </div>
            </div>
            
            <div class="optimizer-panel enabled" id="rmsprop-panel">
                <div class="optimizer-header">
                    <input type="checkbox" class="optimizer-checkbox" id="rmsprop-checkbox" checked onchange="toggleOptimizer('rmsprop')">
                    <div class="optimizer-color" style="background-color: #7b1fa2;" id="rmsprop-color"></div>
                    <div class="optimizer-title">RMSprop</div>
                    <input type="color" id="rmsprop-color-picker" value="#7b1fa2" onchange="changeOptimizerColor('rmsprop', this.value)">
                </div>
                <div class="optimizer-params">
                    <div class="param-group">
                        <div class="param-label">Learning Rate</div>
                        <input type="number" class="param-input" id="rmsprop-lr" value="0.01" step="0.001" min="0.0001" max="1">
                    </div>
                    <div class="param-group">
                        <div class="param-label">Beta</div>
                        <input type="number" class="param-input" id="rmsprop-beta" value="0.9" step="0.01" min="0" max="0.99">
                    </div>
                    <div class="param-group">
                        <div class="param-label">Epsilon</div>
                        <input type="number" class="param-input" id="rmsprop-eps" value="1e-8" step="1e-9" min="1e-12" max="1e-6">
                    </div>
                </div>
            </div>
            
            <div class="optimizer-panel enabled" id="adadelta-panel">
                <div class="optimizer-header">
                    <input type="checkbox" class="optimizer-checkbox" id="adadelta-checkbox" checked onchange="toggleOptimizer('adadelta')">
                    <div class="optimizer-color" style="background-color: #ffc107;" id="adadelta-color"></div>
                    <div class="optimizer-title">AdaDelta</div>
                    <input type="color" id="adadelta-color-picker" value="#ffc107" onchange="changeOptimizerColor('adadelta', this.value)">
                </div>
                <div class="optimizer-params">
                    <div class="param-group">
                        <div class="param-label">Rho</div>
                        <input type="number" class="param-input" id="adadelta-rho" value="0.9" step="0.01" min="0" max="0.99">
                    </div>
                    <div class="param-group">
                        <div class="param-label">Epsilon</div>
                        <input type="number" class="param-input" id="adadelta-eps" value="1e-6" step="1e-7" min="1e-12" max="1e-3">
                    </div>
                </div>
            </div>
            
            <!-- Gradient Vectors Control -->
            <div class="gradient-control">
                <label class="gradient-checkbox-label">
                    <input type="checkbox" id="show-gradient-vectors" onchange="toggleGradientVectors()">
                    <span>Show Gradient Vectors on 2D Contours</span>
                </label>
            </div>
            
            <!-- Color Configuration Control -->
            <div class="color-config-control">
                <div class="color-config-header">
                    <span class="color-config-title">🎨 Color Configuration</span>
                </div>
                <div class="color-config-params">
                    <div class="color-param-group">
                        <div class="color-param-label">Cold Color (Low Heights)</div>
                        <input type="color" id="cold-color-picker" value="#ff4444" onchange="updateColorConfiguration()">
                    </div>
                    <div class="color-param-group">
                        <div class="color-param-label">Hot Color (High Heights)</div>
                        <input type="color" id="hot-color-picker" value="#4444ff" onchange="updateColorConfiguration()">
                    </div>
                </div>
            </div>

            <!-- Detailed Logging Selector -->
            <div class="logging-control">
                <div class="logging-header">
                    <span class="logging-title">📊 Detailed Logging</span>
                </div>
                <div class="logging-params">
                    <div class="logging-param-group">
                        <div class="logging-param-label">Select Optimizer for Detailed Logging:</div>
                        <div class="logging-radio-group">
                            <label class="logging-radio-option">
                                <input type="radio" name="logging-optimizer" value="sgd" onchange="selectLoggingOptimizer('sgd')" checked>
                                <span>SGD</span>
                            </label>
                            <label class="logging-radio-option">
                                <input type="radio" name="logging-optimizer" value="momentum" onchange="selectLoggingOptimizer('momentum')">
                                <span>Momentum</span>
                            </label>
                            <label class="logging-radio-option">
                                <input type="radio" name="logging-optimizer" value="adagrad" onchange="selectLoggingOptimizer('adagrad')">
                                <span>AdaGrad</span>
                            </label>
                            <label class="logging-radio-option">
                                <input type="radio" name="logging-optimizer" value="adam" onchange="selectLoggingOptimizer('adam')">
                                <span>Adam</span>
                            </label>
                            <label class="logging-radio-option">
                                <input type="radio" name="logging-optimizer" value="rmsprop" onchange="selectLoggingOptimizer('rmsprop')">
                                <span>RMSprop</span>
                            </label>
                            <label class="logging-radio-option">
                                <input type="radio" name="logging-optimizer" value="adadelta" onchange="selectLoggingOptimizer('adadelta')">
                                <span>AdaDelta</span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        </div>
        
        <div class="comparison-controls">
            <button onclick="startComparison()">🚀 Start Comparison</button>
            <button onclick="stopComparison()">⏹️ Stop All</button>
            <button onclick="resetComparison()">🔄 Reset All</button>
            <button onclick="stepComparison()">👆 Step All</button>
            <button onclick="randomStartComparison()">🎲 Random Start</button>
            <button onclick="toggleWireframe()">Toggle Wireframe</button>
        </div>
        
            </div>
    
    <div class="views-container">
        <!-- 3D Surface View Container -->
        <div class="view-container" id="view3d-container">
            <div class="view-header">
                <div class="view-title">
                    <span class="view-label">🎯 3D Surface View</span>
                    <div class="view-controls">
                        <div class="optimizer-controls-compact" id="3d-optimizer-controls" style="display: none;">
                            <button onclick="startComparison()" class="control-btn-compact" title="Start">🚀</button>
                            <button onclick="stopComparison()" class="control-btn-compact" title="Stop">⏹️</button>
                            <button onclick="resetComparison()" class="control-btn-compact" title="Reset">🔄</button>
                            <button onclick="stepComparison()" class="control-btn-compact" title="Step">👆</button>
                            <button onclick="randomStartComparison()" class="control-btn-compact" title="Random Start">🎲</button>
                        </div>
                        <button class="fullscreen-btn" onclick="toggleFullscreen('3d')" title="Toggle Fullscreen">⛶</button>
                        <span class="view-status" id="3d-status">Active</span>
                    </div>
                </div>
            </div>
            <div class="view-content" id="view3d-content">
                <canvas id="canvas3d" class="canvas-3d" width="480" height="400"></canvas>
            </div>
        </div>
        
        <!-- 2D Contour View Container -->
        <div class="view-container" id="view2d-container">
            <div class="view-header">
                <div class="view-title">
                    <span class="view-label">📊 2D contour view</span>
                    <div class="view-controls">
                        <div class="optimizer-controls-compact" id="2d-optimizer-controls" style="display: none;">
                            <button onclick="startComparison()" class="control-btn-compact" title="Start">🚀</button>
                            <button onclick="stopComparison()" class="control-btn-compact" title="Stop">⏹️</button>
                            <button onclick="resetComparison()" class="control-btn-compact" title="Reset">🔄</button>
                            <button onclick="stepComparison()" class="control-btn-compact" title="Step">👆</button>
                        </div>
                        <div class="zoom-controls-compact">
                            <button onclick="zoomIn2D()" class="zoom-btn-compact" title="Zoom In">+</button>
                            <button onclick="zoomOut2D()" class="zoom-btn-compact" title="Zoom Out">-</button>
                            <button onclick="resetZoom2D()" class="zoom-btn-compact" title="Reset Zoom">c</button>
                            <span class="zoom-level-compact" id="zoom-level-compact">1.0x</span>
                        </div>
                        <button class="fullscreen-btn" onclick="toggleFullscreen('2d')" title="Toggle Fullscreen">⛶</button>
                        <span class="view-status" id="2d-status">Active</span>
                    </div>
                </div>
            </div>
            <div class="view-content" id="view2d-content">
                <canvas id="canvas2d" class="canvas-2d" width="480" height="400"></canvas>
                <div id="mouse-coordinates" class="mouse-coordinates">(0.00, 0.00)</div>
            </div>
            </div>
        </div>
        
    <!-- Optimizer Comparison Charts Panel -->
    <div class="comparison-charts-section">
        <div class="comparison-charts-header" onclick="toggleComparisonChartsContainer()">
            <div class="comparison-charts-title">
                <span class="toggle-icon" id="charts-toggle-icon">▼</span>
                <span class="comparison-charts-label">📊 Optimizer Performance Comparison</span>
                <span class="comparison-charts-count" id="comparison-charts-count">Loss & Gradient Analysis</span>
            </div>
            <div class="comparison-charts-controls">
                <button class="charts-btn" onclick="clearComparisonCharts(event)" title="Clear all chart data">🗑️</button>
            </div>
        </div>
        <div class="comparison-charts-content" id="comparison-charts-container">
            <div class="charts-display">
                <!-- Loss Comparison Chart -->
                <div class="chart-section">
                    <div class="chart-title">📉 Loss Function Over Time</div>
                    <div class="chart-container">
                        <canvas id="loss-chart" width="1200" height="200"></canvas>
                        <div class="chart-legend" id="loss-legend"></div>
                    </div>
                </div>
                
                <!-- Gradient Magnitude Comparison Chart -->
                <div class="chart-section">
                    <div class="chart-title">📈 Gradient Magnitude Over Time</div>
                    <div class="chart-container">
                        <canvas id="gradient-magnitude-chart" width="1200" height="200"></canvas>
                        <div class="chart-legend" id="gradient-legend"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Detailed Calculation Panel -->
    <div class="calculation-section">
        <div class="calculation-header">
            <div class="calculation-title" onclick="toggleCalculationContainer()">
                <span class="toggle-icon" id="calc-toggle-icon">▼</span>
                <span class="calculation-label">🧮 Training-loop and detailed calculation</span>
                <span class="calculation-count" id="calculation-count">Select optimizer to see calculations</span>
            </div>
            <div class="calculation-controls">
                <button class="calc-btn" id="pseudocode-btn" onclick="togglePseudocode(event)" title="Hide Algorithm Pseudocode" style="background: rgba(39, 174, 96, 0.8);">📝</button>
                <button class="calc-btn" onclick="copyCalculations(event)" title="Copy calculations to clipboard">📋</button>
                <button class="calc-btn" onclick="clearCalculations(event)" title="Clear calculation history">🗑️</button>
            </div>
        </div>
        <div class="calculation-content" id="calculation-container">
            <div class="calculation-display">
                <!-- Optimizer Pseudocode Section -->
                <div class="pseudocode-section" id="pseudocode-section" style="display: block;">
                    <div class="pseudocode-title" id="pseudocode-title">📝 Algorithm Pseudocode</div>
                    <div class="pseudocode-content" id="pseudocode-content">
                        <pre><code id="pseudocode-code">Select an optimizer to see pseudocode</code></pre>
                    </div>
                </div>
                
                <div class="calc-step" id="calc-step">
                    <div class="calc-step-title">Step-by-step Calculations</div>
                    <div class="calc-content" id="calc-content">
                        Select an optimizer and run optimization to see detailed calculations
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let canvas3d, gl3d;
        let canvas2d, ctx2d;
        let program3d;
        let rotationX = -0.2, rotationY = 0; // Slightly adjusted for better view of entire surface
        let mouseX = 0, mouseY = 0;
        let isMouseDown = false;
        let zoom = 1;
        let wireframeMode = true; // Default to wireframe for SGD visualization
        let autoRotate = false;
        let debugMode = false;
        let faceCullingEnabled = false;
        let enhancedLighting = true;
        let showContours = false;

        // SGD Algorithm variables
        let sgdRunning = false;
        let sgdPath = [];
        let currentPosition = { x: 0, y: 0, z: 0 };
        let learningRate = 0.0005; // Much smaller for tiny steps on Rosenbrock
        let stepSize = 0.01;
        let maxSteps = 1000;
        let currentStep = 0;
        let sgdAnimationId = null;
        let showGradients = true;
        let showPath = true;
        
        // Current function selection
        let currentFunction = 'himmelblau';
        
        // Multiple optimizers data with highly distinct, bold colors
        let optimizers = {
            sgd: {
                enabled: true,
                color: '#d32f2f', // Deep Red - Bold, classic
                position: { x: 0.54, y: -0.74, z: 0 },
                path: [],
                step: 0,
                state: {},
                params: { learningRate: 0.002 }
            },
        momentum: {
            enabled: true,
            color: '#0288d1', // Light Blue - Distinct from AdaDelta
            position: { x: 0.54, y: -0.74, z: 0 },
            path: [],
            step: 0,
            state: { vx: 0, vy: 0 },
            params: { learningRate: 0.002, beta: 0.9 }
        },
            adagrad: {
                enabled: true,
                color: '#388e3c', // Deep Green - Distinct from red/blue
                position: { x: 0.54, y: -0.74, z: 0 },
                path: [],
                step: 0,
                state: { sx: 0, sy: 0 },
                params: { learningRate: 0.1, epsilon: 1e-8 }
            },
            adam: {
                enabled: true,
                color: '#f57c00', // Deep Orange - Bold and visible
                position: { x: 0.54, y: -0.74, z: 0 },
                path: [],
                step: 0,
                state: { mx: 0, my: 0, vx: 0, vy: 0, t: 0 },
                params: { learningRate: 0.01, beta1: 0.9, beta2: 0.999, epsilon: 1e-8 }
            },
            rmsprop: {
                enabled: true,
                color: '#7b1fa2', // Deep Purple - Distinct and bold
                position: { x: 0.54, y: -0.74, z: 0 },
                path: [],
                step: 0,
                state: { sx: 0, sy: 0 },
                params: { learningRate: 0.01, beta: 0.9, epsilon: 1e-8 }
            },
        adadelta: {
            enabled: true,
            color: '#ffc107', // Amber Yellow - Distinct and vibrant
            position: { x: 0.54, y: -0.74, z: 0 },
            path: [],
            step: 0,
            state: { sx: 0, sy: 0, deltaX: 0, deltaY: 0 },
            params: { rho: 0.9, epsilon: 1e-6 }
        }
        };
        
        let comparisonRunning = false;
        let comparisonAnimationId = null;
        const MAX_STEPS = 400; // Maximum number of optimization steps
        
        // 2D View Zoom variables
        let view2dZoom = 1.0;
        let view2dCenterX = 0.54;
        let view2dCenterY = -0.74;
        let view2dRange = 16; // Default range: -8 to 8
        
        // 2D View Pan variables
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let panStartCenterX = 0;
        let panStartCenterY = 0;
        
        // Function definitions
        const functions = {
            himmelblau: {
                name: 'Himmelblau Function',
                formula: 'f(w₁,w₂) = (w₁² + w₂ - 11)² + (w₁ + w₂² - 7)²',
                minima: '4 minima at (3, 2), (-2.81, 3.13), (-3.78, -3.28), (3.58, -1.85)',
                func: (x, y) => Math.pow(x*x + y - 11, 2) + Math.pow(x + y*y - 7, 2),
                gradient: (x, y) => {
                    const term1 = x*x + y - 11;
                    const term2 = x + y*y - 7;
                    return { x: 4 * x * term1 + 2 * term2, y: 2 * term1 + 4 * y * term2 };
                },
                scale: 0.02,
                defaultStart: { x: 0.54, y: -0.74 },
                xMin: -6, xMax: 6, yMin: -6, yMax: 6
            },
            rosenbrock: {
                name: 'Rosenbrock Function',
                formula: 'f(x,y) = 100(y - x²)² + (1 - x)²',
                minima: '1 minimum at (1, 1) with value 0',
                func: (x, y) => 100 * Math.pow(y - x*x, 2) + Math.pow(1 - x, 2),
                gradient: (x, y) => {
                    const term1 = y - x*x;
                    const term2 = 1 - x;
                    return { x: -400 * x * term1 - 2 * term2, y: 200 * term1 };
                },
                scale: 0.002,
                defaultStart: { x: -2, y: -1 },
                xMin: -2, xMax: 2, yMin: -1, yMax: 3
            },
            quadratic: {
                name: 'Quadratic Bowl',
                formula: 'f(x,y) = x² + y²',
                minima: '1 minimum at (0, 0) with value 0',
                func: (x, y) => x*x + y*y,
                gradient: (x, y) => {
                    return { x: 2 * x, y: 2 * y };
                },
                scale: 1,
                defaultStart: { x: -3, y: -3 },
                xMin: -5, xMax: 5, yMin: -5, yMax: 5
            },
            booth: {
                name: 'Booth Function',
                formula: 'f(x,y) = (x + 2y - 7)² + (2x + y - 5)²',
                minima: '1 minimum at (1, 3) with value 0',
                func: (x, y) => Math.pow(x + 2*y - 7, 2) + Math.pow(2*x + y - 5, 2),
                gradient: (x, y) => {
                    const term1 = x + 2*y - 7;
                    const term2 = 2*x + y - 5;
                    return { x: 2 * term1 + 4 * term2, y: 4 * term1 + 2 * term2 };
                },
                scale: 0.02,
                defaultStart: { x: -2, y: -2 },
                xMin: -10, xMax: 10, yMin: -10, yMax: 10
            }
        };

        // Function change handler
        function changeFunction(functionName) {
            currentFunction = functionName;
            
            // Update radio button selection
            document.querySelectorAll('.function-radio').forEach(radio => {
                radio.checked = radio.value === functionName;
            });
            
            // Update panel visual states
            document.querySelectorAll('.function-panel').forEach(panel => {
                panel.classList.remove('enabled');
            });
            document.getElementById(`${functionName}-panel`).classList.add('enabled');
            
            // Update functions count display
            const func = functions[currentFunction];
            document.getElementById('functions-count').textContent = func.name;
            
            
            // Update function parameters from UI
            updateFunctionParameters();
            
            // Stop comparison and reset all optimizers
            stopComparison();
            resetComparison();
            
            // Regenerate surface
            createCurrentFunctionSurface();
            
            // // console.log(`🔄 Switched to ${func.name}`);
        }
        
        // Update function parameters from UI inputs
        function updateFunctionParameters() {
            const func = functions[currentFunction];
            
            // Update range parameters
            func.xMin = parseFloat(document.getElementById(`${currentFunction}-xmin`).value);
            func.xMax = parseFloat(document.getElementById(`${currentFunction}-xmax`).value);
            func.yMin = parseFloat(document.getElementById(`${currentFunction}-ymin`).value);
            func.yMax = parseFloat(document.getElementById(`${currentFunction}-ymax`).value);
            
            // // console.log(`📊 Updated ${currentFunction} parameters: x[${func.xMin}, ${func.xMax}], y[${func.yMin}, ${func.yMax}]`);
        }
        
        // Initialize function parameters and add change listeners
        function initializeFunctionParameters() {
            const functionNames = ['himmelblau', 'rosenbrock', 'quadratic', 'booth'];
            
            functionNames.forEach(funcName => {
                const func = functions[funcName];
                
                // Set initial values in UI
                document.getElementById(`${funcName}-xmin`).value = func.xMin;
                document.getElementById(`${funcName}-xmax`).value = func.xMax;
                document.getElementById(`${funcName}-ymin`).value = func.yMin;
                document.getElementById(`${funcName}-ymax`).value = func.yMax;
                
                // Add change listeners
                ['xmin', 'xmax', 'ymin', 'ymax'].forEach(param => {
                    document.getElementById(`${funcName}-${param}`).addEventListener('change', () => {
                        updateFunctionParameters();
                        // Regenerate surface if this is the current function
                        if (currentFunction === funcName) {
                            createCurrentFunctionSurface();
                            render2DView();
                        }
                    });
                });
            });
            
            // // console.log('✅ Function parameters initialized');
        }
        
        // Toggle optimizer on/off
        function toggleOptimizer(optimizerName) {
            const checkbox = document.getElementById(`${optimizerName}-checkbox`);
            const panel = document.getElementById(`${optimizerName}-panel`);
            
            optimizers[optimizerName].enabled = checkbox.checked;
            
            if (checkbox.checked) {
                panel.classList.remove('disabled');
                panel.classList.add('enabled');
            } else {
                panel.classList.remove('enabled');
                panel.classList.add('disabled');
            }
            
            // // console.log(`${optimizerName} optimizer ${checkbox.checked ? 'enabled' : 'disabled'}`);
            updateOptimizersCount();
        }
        
        // Toggle optimizers container (minimize/expand)
        function toggleOptimizersContainer() {
            const container = document.querySelector('.optimizers-container');
            const toggleIcon = document.getElementById('toggle-icon');
            
            container.classList.toggle('collapsed');
            
            // Update toggle icon
            if (container.classList.contains('collapsed')) {
                toggleIcon.textContent = '▶';
            } else {
                toggleIcon.textContent = '▼';
            }
            
            // // console.log(`Optimizers panel ${container.classList.contains('collapsed') ? 'collapsed' : 'expanded'}`);
        }
        
        // Toggle gradient vectors display
        function toggleGradientVectors() {
            const checkbox = document.getElementById('show-gradient-vectors');
            window.showGradientVectors = checkbox.checked;
            // Trigger re-render of 2D view
            render2DView();
        }
        
        // Initialize gradient vectors as disabled by default
        window.showGradientVectors = false;
        
        // Color configuration variables
        window.coldColor = '#ff4444'; // Default cold color (red)
        window.hotColor = '#4444ff';  // Default hot color (blue)
        
        // Detailed logging variables
        window.selectedLoggingOptimizer = 'sgd'; // Default to SGD
        window.detailedCalculations = [];
        
        // Comparison charts data
        window.comparisonChartsData = {
            loss: {}, // {optimizerName: [{step, value}, ...]}
            gradientMagnitude: {} // {optimizerName: [{step, value}, ...]}
        };
        
        // Update color configuration
        function updateColorConfiguration() {
            window.coldColor = document.getElementById('cold-color-picker').value;
            window.hotColor = document.getElementById('hot-color-picker').value;
            
            // Regenerate contours with new colors
            generateContours();
            render2DView();
            
            // Regenerate 3D surface with new colors
            createCurrentFunctionSurface();
            render3DView();
        }
        
        // Select optimizer for detailed logging
        function selectLoggingOptimizer(optimizerName) {
            window.selectedLoggingOptimizer = optimizerName;
            
            // Also enable the optimizer in comparison if not already enabled
            const checkbox = document.getElementById(`${optimizerName}-checkbox`);
            if (checkbox && !checkbox.checked) {
                checkbox.checked = true;
                toggleOptimizer(optimizerName);
            }
            
            // Update calculation count display
            updateCalculationCount();
            
            // Clear previous calculations and chart data
            window.detailedCalculations = [];
            updateCalculationDisplay();
            
            // Update pseudocode if it's visible
            const pseudocodeSection = document.getElementById('pseudocode-section');
            if (pseudocodeSection && pseudocodeSection.style.display !== 'none') {
                updatePseudocode();
            }
        }
        
        // Toggle calculation container (minimize/expand)
        function toggleCalculationContainer() {
            const container = document.querySelector('.calculation-content');
            const toggleIcon = document.getElementById('calc-toggle-icon');
            
            container.classList.toggle('collapsed');
            
            // Update toggle icon
            if (container.classList.contains('collapsed')) {
                toggleIcon.textContent = '▶';
            } else {
                toggleIcon.textContent = '▼';
            }
        }
        
        // Update calculation count display
        function updateCalculationCount() {
            const countElement = document.getElementById('calculation-count');
            
            if (window.selectedLoggingOptimizer) {
                const optimizerNames = {
                    'sgd': 'SGD',
                    'momentum': 'Momentum',
                    'adagrad': 'AdaGrad',
                    'adam': 'Adam',
                    'rmsprop': 'RMSprop',
                    'adadelta': 'AdaDelta'
                };
                
                countElement.textContent = optimizerNames[window.selectedLoggingOptimizer] || 'Unknown';
            } else {
                countElement.textContent = 'Select optimizer to see calculations';
            }
        }
        
        // Update calculation display
        function updateCalculationDisplay() {
            const contentElement = document.getElementById('calc-content');
            
            if (window.detailedCalculations.length === 0) {
                contentElement.textContent = 'Select an optimizer and run optimization to see detailed calculations';
                return;
            }
            
            let displayText = '';
            window.detailedCalculations.forEach((calc, index) => {
                displayText += `=== Step ${index + 1} ===\n`;
                displayText += `Optimizer: ${calc.optimizer}\n`;
                displayText += `Current Position: w1 = ${calc.position.x.toFixed(6)}, w2 = ${calc.position.y.toFixed(6)}\n`;
                displayText += `Function Value: f(w1,w2) = ${calc.functionValue.toFixed(6)}\n`;
                displayText += `Gradient: ∇f = (${calc.gradient.x.toFixed(6)}, ${calc.gradient.y.toFixed(6)})\n`;
                
                if (calc.optimizer === 'sgd') {
                    displayText += `SGD Update:\n`;
                    displayText += `  w1_new = w1 - α * ∇f_w1 = ${calc.position.x.toFixed(6)} - ${calc.params.learningRate} * ${calc.gradient.x.toFixed(6)} = ${calc.newPosition.x.toFixed(6)}\n`;
                    displayText += `  w2_new = w2 - α * ∇f_w2 = ${calc.position.y.toFixed(6)} - ${calc.params.learningRate} * ${calc.gradient.y.toFixed(6)} = ${calc.newPosition.y.toFixed(6)}\n`;
                } else if (calc.optimizer === 'momentum') {
                    displayText += `Momentum Update:\n`;
                    displayText += `  v_w1 = β * v_w1 + α * ∇f_w1 = ${calc.params.beta} * ${calc.state.vx.toFixed(6)} + ${calc.params.learningRate} * ${calc.gradient.x.toFixed(6)} = ${calc.newState.vx.toFixed(6)}\n`;
                    displayText += `  v_w2 = β * v_w2 + α * ∇f_w2 = ${calc.params.beta} * ${calc.state.vy.toFixed(6)} + ${calc.params.learningRate} * ${calc.gradient.y.toFixed(6)} = ${calc.newState.vy.toFixed(6)}\n`;
                    displayText += `  w1_new = w1 - v_w1 = ${calc.position.x.toFixed(6)} - ${calc.newState.vx.toFixed(6)} = ${calc.newPosition.x.toFixed(6)}\n`;
                    displayText += `  w2_new = w2 - v_w2 = ${calc.position.y.toFixed(6)} - ${calc.newState.vy.toFixed(6)} = ${calc.newPosition.y.toFixed(6)}\n`;
                } else if (calc.optimizer === 'adagrad') {
                    displayText += `AdaGrad Update:\n`;
                    displayText += `  s_w1 += (∇f_w1)² = ${calc.state.sx.toFixed(6)} + ${(calc.gradient.x * calc.gradient.x).toFixed(6)} = ${calc.newState.sx.toFixed(6)}\n`;
                    displayText += `  s_w2 += (∇f_w2)² = ${calc.state.sy.toFixed(6)} + ${(calc.gradient.y * calc.gradient.y).toFixed(6)} = ${calc.newState.sy.toFixed(6)}\n`;
                    displayText += `  w1_new = w1 - α/√(s_w1 + ε) * ∇f_w1 = ${calc.position.x.toFixed(6)} - ${calc.params.learningRate}/√(${calc.newState.sx.toFixed(6)} + ${calc.params.epsilon}) * ${calc.gradient.x.toFixed(6)} = ${calc.newPosition.x.toFixed(6)}\n`;
                    displayText += `  w2_new = w2 - α/√(s_w2 + ε) * ∇f_w2 = ${calc.position.y.toFixed(6)} - ${calc.params.learningRate}/√(${calc.newState.sy.toFixed(6)} + ${calc.params.epsilon}) * ${calc.gradient.y.toFixed(6)} = ${calc.newPosition.y.toFixed(6)}\n`;
                } else if (calc.optimizer === 'adam') {
                    displayText += `Adam Update:\n`;
                    displayText += `  m_w1 = β1 * m_w1 + (1-β1) * ∇f_w1 = ${calc.params.beta1} * ${calc.state.mx.toFixed(6)} + (1-${calc.params.beta1}) * ${calc.gradient.x.toFixed(6)} = ${calc.newState.mx.toFixed(6)}\n`;
                    displayText += `  m_w2 = β1 * m_w2 + (1-β1) * ∇f_w2 = ${calc.params.beta1} * ${calc.state.my.toFixed(6)} + (1-${calc.params.beta1}) * ${calc.gradient.y.toFixed(6)} = ${calc.newState.my.toFixed(6)}\n`;
                    displayText += `  v_w1 = β2 * v_w1 + (1-β2) * (∇f_w1)² = ${calc.params.beta2} * ${calc.state.vx.toFixed(6)} + (1-${calc.params.beta2}) * ${(calc.gradient.x * calc.gradient.x).toFixed(6)} = ${calc.newState.vx.toFixed(6)}\n`;
                    displayText += `  v_w2 = β2 * v_w2 + (1-β2) * (∇f_w2)² = ${calc.params.beta2} * ${calc.state.vy.toFixed(6)} + (1-${calc.params.beta2}) * ${(calc.gradient.y * calc.gradient.y).toFixed(6)} = ${calc.newState.vy.toFixed(6)}\n`;
                    displayText += `  m̂_w1 = m_w1 / (1-β1^t) = ${calc.newState.mx.toFixed(6)} / (1-${calc.params.beta1}^${calc.state.t}) = ${calc.biasCorrected.mx.toFixed(6)}\n`;
                    displayText += `  m̂_w2 = m_w2 / (1-β1^t) = ${calc.newState.my.toFixed(6)} / (1-${calc.params.beta1}^${calc.state.t}) = ${calc.biasCorrected.my.toFixed(6)}\n`;
                    displayText += `  v̂_w1 = v_w1 / (1-β2^t) = ${calc.newState.vx.toFixed(6)} / (1-${calc.params.beta2}^${calc.state.t}) = ${calc.biasCorrected.vx.toFixed(6)}\n`;
                    displayText += `  v̂_w2 = v_w2 / (1-β2^t) = ${calc.newState.vy.toFixed(6)} / (1-${calc.params.beta2}^${calc.state.t}) = ${calc.biasCorrected.vy.toFixed(6)}\n`;
                    displayText += `  w1_new = w1 - α * m̂_w1 / √(v̂_w1 + ε) = ${calc.position.x.toFixed(6)} - ${calc.params.learningRate} * ${calc.biasCorrected.mx.toFixed(6)} / √(${calc.biasCorrected.vx.toFixed(6)} + ${calc.params.epsilon}) = ${calc.newPosition.x.toFixed(6)}\n`;
                    displayText += `  w2_new = w2 - α * m̂_w2 / √(v̂_w2 + ε) = ${calc.position.y.toFixed(6)} - ${calc.params.learningRate} * ${calc.biasCorrected.my.toFixed(6)} / √(${calc.biasCorrected.vy.toFixed(6)} + ${calc.params.epsilon}) = ${calc.newPosition.y.toFixed(6)}\n`;
                } else if (calc.optimizer === 'rmsprop') {
                    displayText += `RMSprop Update:\n`;
                    displayText += `  s_w1 = ρ * s_w1 + (1-ρ) * (∇f_w1)² = ${calc.params.beta} * ${calc.state.sx.toFixed(6)} + (1-${calc.params.beta}) * ${(calc.gradient.x * calc.gradient.x).toFixed(6)} = ${calc.newState.sx.toFixed(6)}\n`;
                    displayText += `  s_w2 = ρ * s_w2 + (1-ρ) * (∇f_w2)² = ${calc.params.beta} * ${calc.state.sy.toFixed(6)} + (1-${calc.params.beta}) * ${(calc.gradient.y * calc.gradient.y).toFixed(6)} = ${calc.newState.sy.toFixed(6)}\n`;
                    displayText += `  w1_new = w1 - α * ∇f_w1 / √(s_w1 + ε) = ${calc.position.x.toFixed(6)} - ${calc.params.learningRate} * ${calc.gradient.x.toFixed(6)} / √(${calc.newState.sx.toFixed(6)} + ${calc.params.epsilon}) = ${calc.newPosition.x.toFixed(6)}\n`;
                    displayText += `  w2_new = w2 - α * ∇f_w2 / √(s_w2 + ε) = ${calc.position.y.toFixed(6)} - ${calc.params.learningRate} * ${calc.gradient.y.toFixed(6)} / √(${calc.newState.sy.toFixed(6)} + ${calc.params.epsilon}) = ${calc.newPosition.y.toFixed(6)}\n`;
                } else if (calc.optimizer === 'adadelta') {
                    displayText += `AdaDelta Update:\n`;
                    displayText += `  s_w1 = ρ * s_w1 + (1-ρ) * (∇f_w1)² = ${calc.params.rho} * ${calc.state.sx.toFixed(6)} + (1-${calc.params.rho}) * ${(calc.gradient.x * calc.gradient.x).toFixed(6)} = ${calc.newState.sx.toFixed(6)}\n`;
                    displayText += `  s_w2 = ρ * s_w2 + (1-ρ) * (∇f_w2)² = ${calc.params.rho} * ${calc.state.sy.toFixed(6)} + (1-${calc.params.rho}) * ${(calc.gradient.y * calc.gradient.y).toFixed(6)} = ${calc.newState.sy.toFixed(6)}\n`;
                    displayText += `  Δw1 = -√(E[Δw1²] + ε) / √(s_w1 + ε) * ∇f_w1 = -√(${calc.state.deltaX.toFixed(6)} + ${calc.params.epsilon}) / √(${calc.newState.sx.toFixed(6)} + ${calc.params.epsilon}) * ${calc.gradient.x.toFixed(6)} = ${(calc.newPosition.x - calc.position.x).toFixed(6)}\n`;
                    displayText += `  Δw2 = -√(E[Δw2²] + ε) / √(s_w2 + ε) * ∇f_w2 = -√(${calc.state.deltaY.toFixed(6)} + ${calc.params.epsilon}) / √(${calc.newState.sy.toFixed(6)} + ${calc.params.epsilon}) * ${calc.gradient.y.toFixed(6)} = ${(calc.newPosition.y - calc.position.y).toFixed(6)}\n`;
                    displayText += `  w1_new = w1 + Δw1 = ${calc.position.x.toFixed(6)} + ${(calc.newPosition.x - calc.position.x).toFixed(6)} = ${calc.newPosition.x.toFixed(6)}\n`;
                    displayText += `  w2_new = w2 + Δw2 = ${calc.position.y.toFixed(6)} + ${(calc.newPosition.y - calc.position.y).toFixed(6)} = ${calc.newPosition.y.toFixed(6)}\n`;
                }
                
                displayText += '\n';
            });
            
            contentElement.textContent = displayText;
        }
        
        // Optimizer pseudocodes
        const optimizerPseudocodes = {
            sgd: `# SGD Training Loop (Pseudocode)
def train_model_sgd(X, y, learning_rate=0.01, epochs=100):
    # Initialize weights randomly
    weights = random_initialization()
    
    for epoch in range(epochs):
        # Shuffle data
        X_shuffled, y_shuffled = shuffle(X, y)
        
        for batch in batches(X_shuffled, y_shuffled):
            # Forward pass
            predictions = forward_pass(batch.X, weights)
            
            # Compute loss
            loss = compute_loss(predictions, batch.y)
            
            # Compute gradients
            gradients = compute_gradients(loss, weights)
            
            # Update weights (SGD update rule)
            weights = weights - learning_rate * gradients
            
        # Log progress
        if epoch % 10 == 0:
            print(f"Epoch {epoch}, Loss: {loss}")`,
            
            momentum: `# Momentum Training Loop (Pseudocode)
def train_model_momentum(X, y, learning_rate=0.01, beta=0.9, epochs=100):
    # Initialize weights and velocity
    weights = random_initialization()
    velocity = zeros_like(weights)
    
    for epoch in range(epochs):
        # Shuffle data
        X_shuffled, y_shuffled = shuffle(X, y)
        
        for batch in batches(X_shuffled, y_shuffled):
            # Forward pass
            predictions = forward_pass(batch.X, weights)
            
            # Compute loss
            loss = compute_loss(predictions, batch.y)
            
            # Compute gradients
            gradients = compute_gradients(loss, weights)
            
            # Update velocity (exponentially weighted average)
            velocity = beta * velocity + (1 - beta) * gradients
            
            # Update weights (Momentum update rule)
            weights = weights - learning_rate * velocity
            
        # Log progress
        if epoch % 10 == 0:
            print(f"Epoch {epoch}, Loss: {loss}")`,
            
            adagrad: `# AdaGrad Training Loop (Pseudocode)
def train_model_adagrad(X, y, learning_rate=0.1, epsilon=1e-8, epochs=100):
    # Initialize weights and squared gradients accumulator
    weights = random_initialization()
    squared_grads = zeros_like(weights)
    
    for epoch in range(epochs):
        # Shuffle data
        X_shuffled, y_shuffled = shuffle(X, y)
        
        for batch in batches(X_shuffled, y_shuffled):
            # Forward pass
            predictions = forward_pass(batch.X, weights)
            
            # Compute loss
            loss = compute_loss(predictions, batch.y)
            
            # Compute gradients
            gradients = compute_gradients(loss, weights)
            
            # Accumulate squared gradients
            squared_grads += gradients ** 2
            
            # Update weights (AdaGrad update rule)
            weights = weights - learning_rate * gradients / sqrt(squared_grads + epsilon)
            
        # Log progress
        if epoch % 10 == 0:
            print(f"Epoch {epoch}, Loss: {loss}")`,
            
            adam: `# Adam Training Loop (Pseudocode)
def train_model_adam(X, y, learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-8, epochs=100):
    # Initialize weights, moment estimates, and timestep
    weights = random_initialization()
    m = zeros_like(weights)  # First moment estimate
    v = zeros_like(weights)  # Second moment estimate
    t = 0  # Timestep
    
    for epoch in range(epochs):
        # Shuffle data
        X_shuffled, y_shuffled = shuffle(X, y)
        
        for batch in batches(X_shuffled, y_shuffled):
            t += 1
            
            # Forward pass
            predictions = forward_pass(batch.X, weights)
            
            # Compute loss
            loss = compute_loss(predictions, batch.y)
            
            # Compute gradients
            gradients = compute_gradients(loss, weights)
            
            # Update biased first moment estimate
            m = beta1 * m + (1 - beta1) * gradients
            
            # Update biased second moment estimate
            v = beta2 * v + (1 - beta2) * (gradients ** 2)
            
            # Compute bias-corrected first moment estimate
            m_hat = m / (1 - beta1 ** t)
            
            # Compute bias-corrected second moment estimate
            v_hat = v / (1 - beta2 ** t)
            
            # Update weights (Adam update rule)
            weights = weights - learning_rate * m_hat / (sqrt(v_hat) + epsilon)
            
        # Log progress
        if epoch % 10 == 0:
            print(f"Epoch {epoch}, Loss: {loss}")`,
            
            rmsprop: `# RMSprop Training Loop (Pseudocode)
def train_model_rmsprop(X, y, learning_rate=0.01, beta=0.9, epsilon=1e-8, epochs=100):
    # Initialize weights and squared gradients accumulator
    weights = random_initialization()
    squared_grads = zeros_like(weights)
    
    for epoch in range(epochs):
        # Shuffle data
        X_shuffled, y_shuffled = shuffle(X, y)
        
        for batch in batches(X_shuffled, y_shuffled):
            # Forward pass
            predictions = forward_pass(batch.X, weights)
            
            # Compute loss
            loss = compute_loss(predictions, batch.y)
            
            # Compute gradients
            gradients = compute_gradients(loss, weights)
            
            # Update squared gradients (exponentially weighted average)
            squared_grads = beta * squared_grads + (1 - beta) * (gradients ** 2)
            
            # Update weights (RMSprop update rule)
            weights = weights - learning_rate * gradients / sqrt(squared_grads + epsilon)
            
        # Log progress
        if epoch % 10 == 0:
            print(f"Epoch {epoch}, Loss: {loss}")`,
            
            adadelta: `# AdaDelta Training Loop (Pseudocode)
def train_model_adadelta(X, y, rho=0.9, epsilon=1e-6, epochs=100):
    # Initialize weights and accumulators
    weights = random_initialization()
    squared_grads = zeros_like(weights)    # E[g^2]
    squared_deltas = zeros_like(weights)   # E[Δ^2]
    
    for epoch in range(epochs):
        # Shuffle data
        X_shuffled, y_shuffled = shuffle(X, y)
        
        for batch in batches(X_shuffled, y_shuffled):
            # Forward pass
            predictions = forward_pass(batch.X, weights)
            
            # Compute loss
            loss = compute_loss(predictions, batch.y)
            
            # Compute gradients
            gradients = compute_gradients(loss, weights)
            
            # Accumulate squared gradients
            squared_grads = rho * squared_grads + (1 - rho) * (gradients ** 2)
            
            # Compute parameter update
            delta_weights = -sqrt(squared_deltas + epsilon) / sqrt(squared_grads + epsilon) * gradients
            
            # Accumulate squared parameter updates
            squared_deltas = rho * squared_deltas + (1 - rho) * (delta_weights ** 2)
            
            # Update weights (AdaDelta update rule)
            weights = weights + delta_weights
            
        # Log progress
        if epoch % 10 == 0:
            print(f"Epoch {epoch}, Loss: {loss}")`
        };
        
        // Update pseudocode based on selected optimizer
        function updatePseudocode() {
            const selectedOptimizer = window.selectedLoggingOptimizer;
            const titleElement = document.getElementById('pseudocode-title');
            const codeElement = document.getElementById('pseudocode-code');
            
            if (optimizerPseudocodes[selectedOptimizer]) {
                const optimizerName = selectedOptimizer.toUpperCase();
                titleElement.textContent = `📝 ${optimizerName} Algorithm Pseudocode`;
                
                // Get the pseudocode text and format it with HTML
                const pseudocodeText = optimizerPseudocodes[selectedOptimizer];
                const formattedCode = formatPseudocodeWithVariables(pseudocodeText);
                codeElement.innerHTML = formattedCode;
            } else {
                titleElement.textContent = '📝 Algorithm Pseudocode';
                codeElement.innerHTML = 'Select an optimizer to see pseudocode';
            }
        }
        
        // Format pseudocode text with highlighted variables
        function formatPseudocodeWithVariables(text) {
            // Define important variables to highlight
            const importantVariables = [
                'weights', 'gradients', 'learning_rate', 'beta', 'beta1', 'beta2', 
                'epsilon', 'rho', 'velocity', 'squared_grads', 'm', 'v', 't',
                'm_hat', 'v_hat', 'delta_weights', 'squared_deltas', 'epochs',
                'X', 'y', 'predictions', 'loss', 'epoch'
            ];
            
            // Create regex pattern for all important variables
            const variablePattern = new RegExp(`\\b(${importantVariables.join('|')})\\b`, 'g');
            
            // Replace variables with highlighted HTML
            return text.replace(variablePattern, '<span class="variable">$1</span>');
        }
        
        // Toggle optimizer pseudocode display
        function togglePseudocode(event) {
            const pseudocodeSection = document.getElementById('pseudocode-section');
            const pseudocodeBtn = document.getElementById('pseudocode-btn');
            
            const isVisible = pseudocodeSection.style.display !== 'none';
            
            if (isVisible) {
                pseudocodeSection.style.display = 'none';
                pseudocodeBtn.style.background = 'rgba(255, 255, 255, 0.2)';
                pseudocodeBtn.title = 'Show Algorithm Pseudocode';
            } else {
                pseudocodeSection.style.display = 'block';
                pseudocodeBtn.style.background = 'rgba(39, 174, 96, 0.8)';
                pseudocodeBtn.title = 'Hide Algorithm Pseudocode';
                
                // Update pseudocode when showing
                updatePseudocode();
            }
        }
        
        // Copy calculations to clipboard
        function copyCalculations() {
            const contentElement = document.getElementById('calc-content');
            const text = contentElement.textContent;
            
            if (!text || text === 'Select an optimizer and run optimization to see detailed calculations') {
                alert('No calculations to copy! Please select an optimizer and run optimization first.');
                return;
            }
            
            navigator.clipboard.writeText(text).then(() => {
                // Show temporary success feedback
                const copyBtn = event.target;
                const originalText = copyBtn.textContent;
                copyBtn.textContent = '✓';
                copyBtn.style.background = 'rgba(39, 174, 96, 0.8)';
                
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.style.background = '';
                }, 1000);
            }).catch(err => {
                console.error('Failed to copy calculations: ', err);
                alert('Failed to copy calculations to clipboard. Please try again.');
            });
        }
        
        // Clear calculation history
        function clearCalculations() {
            if (window.detailedCalculations.length === 0) {
                alert('No calculations to clear!');
                return;
            }
            
            if (confirm('Are you sure you want to clear all calculation history?')) {
                window.detailedCalculations = [];
                updateCalculationDisplay();
                
                
                // Show temporary success feedback
                const clearBtn = event.target;
                const originalText = clearBtn.textContent;
                clearBtn.textContent = '✓';
                clearBtn.style.background = 'rgba(231, 76, 60, 0.8)';
                
                setTimeout(() => {
                    clearBtn.textContent = originalText;
                    clearBtn.style.background = '';
                }, 1000);
            }
        }
        
        
        // Toggle comparison charts container (minimize/expand)
        function toggleComparisonChartsContainer() {
            const container = document.querySelector('.comparison-charts-content');
            const toggleIcon = document.getElementById('charts-toggle-icon');
            
            container.classList.toggle('collapsed');
            
            // Update toggle icon
            if (container.classList.contains('collapsed')) {
                toggleIcon.textContent = '▶';
            } else {
                toggleIcon.textContent = '▼';
            }
        }
        
        // Clear comparison charts data
        function clearComparisonCharts(event) {
            if (Object.keys(window.comparisonChartsData.loss).length === 0 && 
                Object.keys(window.comparisonChartsData.gradientMagnitude).length === 0) {
                alert('No chart data to clear!');
                return;
            }
            
            if (confirm('Are you sure you want to clear all comparison chart data?')) {
                window.comparisonChartsData = {
                    loss: {},
                    gradientMagnitude: {}
                };
                
                // Clear both charts
                clearLossChart();
                clearGradientMagnitudeChart();
                
                // Show temporary success feedback
                const clearBtn = event.target;
                const originalText = clearBtn.textContent;
                clearBtn.textContent = '✓';
                clearBtn.style.background = 'rgba(231, 76, 60, 0.8)';
                
                setTimeout(() => {
                    clearBtn.textContent = originalText;
                    clearBtn.style.background = '';
                }, 1000);
            }
        }
        
        // Clear loss chart
        function clearLossChart() {
            const canvas = document.getElementById('loss-chart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw empty chart with labels
            drawEmptyChart(canvas, 'Loss Function Value', 'Optimization Step');
        }
        
        // Clear gradient magnitude chart
        function clearGradientMagnitudeChart() {
            const canvas = document.getElementById('gradient-magnitude-chart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw empty chart with labels
            drawEmptyChart(canvas, 'Gradient Magnitude', 'Optimization Step');
        }
        
        // Draw empty chart with labels
        function drawEmptyChart(canvas, yLabel, xLabel) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Set up chart area
            const margin = { top: 20, right: 20, bottom: 40, left: 60 };
            
            // Draw axes
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.beginPath();
            // Y-axis
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, height - margin.bottom);
            // X-axis
            ctx.moveTo(margin.left, height - margin.bottom);
            ctx.lineTo(width - margin.right, height - margin.bottom);
            ctx.stroke();
            
            // Draw labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            
            // X-axis label
            ctx.fillText(xLabel, width / 2, height - 5);
            
            // Y-axis label
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText(yLabel, 0, 0);
            ctx.restore();
        }
        
        // Update chart legend
        function updateChartLegend(legendId, chartData) {
            const legend = document.getElementById(legendId);
            if (!legend) return;
            
            legend.innerHTML = '';
            
            Object.keys(chartData).forEach(optimizerName => {
                if (chartData[optimizerName].length > 0) {
                    const optimizer = optimizers[optimizerName];
                    const legendItem = document.createElement('div');
                    legendItem.className = 'legend-item';
                    
                    const colorBox = document.createElement('div');
                    colorBox.className = 'legend-color';
                    colorBox.style.background = optimizer.color;
                    
                    const label = document.createElement('span');
                    label.className = 'legend-label';
                    label.textContent = optimizerName.toUpperCase();
                    
                    legendItem.appendChild(colorBox);
                    legendItem.appendChild(label);
                    legend.appendChild(legendItem);
                }
            });
        }
        
        // Update loss chart
        function updateLossChart() {
            const canvas = document.getElementById('loss-chart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Set up chart area
            const margin = { top: 20, right: 20, bottom: 40, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;
            
            // Collect all data points from all optimizers
            let allSteps = [];
            let allValues = [];
            
            Object.keys(window.comparisonChartsData.loss).forEach(optimizerName => {
                const data = window.comparisonChartsData.loss[optimizerName];
                data.forEach(point => {
                    allSteps.push(point.step);
                    allValues.push(point.value);
                });
            });
            
            if (allSteps.length === 0) {
                drawEmptyChart(canvas, 'Loss Function Value', 'Optimization Step');
                return;
            }
            
            // Find data range
            const minStep = Math.min(...allSteps);
            const maxStep = Math.max(...allSteps);
            const minValue = Math.min(...allValues);
            const maxValue = Math.max(...allValues);
            
            // Add some padding to y-axis
            const valueRange = maxValue - minValue;
            const yMin = Math.max(0, minValue - valueRange * 0.1);
            const yMax = maxValue + valueRange * 0.1;
            
            // Draw grid lines
            ctx.strokeStyle = '#eee';
            ctx.lineWidth = 0.5;
            
            // Horizontal grid lines (y-axis)
            const numHorizontalLines = 5;
            for (let i = 0; i <= numHorizontalLines; i++) {
                const y = margin.top + (chartHeight / numHorizontalLines) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(width - margin.right, y);
                ctx.stroke();
            }
            
            // Vertical grid lines (x-axis)
            const numVerticalLines = Math.min(10, Math.max(1, maxStep - minStep));
            for (let i = 0; i <= numVerticalLines; i++) {
                const x = margin.left + (chartWidth / numVerticalLines) * i;
                ctx.beginPath();
                ctx.moveTo(x, margin.top);
                ctx.lineTo(x, height - margin.bottom);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.beginPath();
            // Y-axis
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, height - margin.bottom);
            // X-axis
            ctx.moveTo(margin.left, height - margin.bottom);
            ctx.lineTo(width - margin.right, height - margin.bottom);
            ctx.stroke();
            
            // Draw lines for each optimizer
            Object.keys(window.comparisonChartsData.loss).forEach(optimizerName => {
                const data = window.comparisonChartsData.loss[optimizerName];
                const optimizer = optimizers[optimizerName];
                const color = optimizer.color;
                
                if (data.length > 1) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 0.8; // Very thin lines for better clarity
                    ctx.beginPath();
                    
                    data.forEach((point, index) => {
                        const x = margin.left + ((point.step - minStep) / (maxStep - minStep)) * chartWidth;
                        const y = height - margin.bottom - ((point.value - yMin) / (yMax - yMin)) * chartHeight;
                        
                        if (index === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    ctx.stroke();
                }
                
                // Draw data points
                ctx.fillStyle = color;
                data.forEach(point => {
                    const x = margin.left + ((point.step - minStep) / (maxStep - minStep)) * chartWidth;
                    const y = height - margin.bottom - ((point.value - yMin) / (yMax - yMin)) * chartHeight;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 2.5, 0, 2 * Math.PI);
                    ctx.fill();
                });
            });
            
            // Draw labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            
            // X-axis label
            ctx.fillText('Optimization Step', width / 2, height - 5);
            
            // Y-axis label
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Loss Function Value', 0, 0);
            ctx.restore();
            
            // Y-axis tick labels
            ctx.textAlign = 'right';
            for (let i = 0; i <= numHorizontalLines; i++) {
                const value = yMin + (yMax - yMin) * (1 - i / numHorizontalLines);
                const y = margin.top + (chartHeight / numHorizontalLines) * i;
                ctx.fillText(value.toFixed(3), margin.left - 5, y + 4);
            }
            
            // X-axis tick labels
            ctx.textAlign = 'center';
            for (let i = 0; i <= numVerticalLines; i++) {
                const value = minStep + (maxStep - minStep) * (i / numVerticalLines);
                const x = margin.left + (chartWidth / numVerticalLines) * i;
                ctx.fillText(Math.round(value).toString(), x, height - margin.bottom + 20);
            }
            
            // Update legend
            updateChartLegend('loss-legend', window.comparisonChartsData.loss);
        }
        
        // Update gradient magnitude chart
        function updateGradientMagnitudeChart() {
            const canvas = document.getElementById('gradient-magnitude-chart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Set up chart area
            const margin = { top: 20, right: 20, bottom: 40, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;
            
            // Collect all data points from all optimizers
            let allSteps = [];
            let allValues = [];
            
            Object.keys(window.comparisonChartsData.gradientMagnitude).forEach(optimizerName => {
                const data = window.comparisonChartsData.gradientMagnitude[optimizerName];
                data.forEach(point => {
                    allSteps.push(point.step);
                    allValues.push(point.value);
                });
            });
            
            if (allSteps.length === 0) {
                drawEmptyChart(canvas, 'Gradient Magnitude', 'Optimization Step');
                return;
            }
            
            // Find data range
            const minStep = Math.min(...allSteps);
            const maxStep = Math.max(...allSteps);
            const minValue = Math.min(...allValues);
            const maxValue = Math.max(...allValues);
            
            // Add some padding to y-axis
            const valueRange = maxValue - minValue;
            const yMin = Math.max(0, minValue - valueRange * 0.1);
            const yMax = maxValue + valueRange * 0.1;
            
            // Draw grid lines
            ctx.strokeStyle = '#eee';
            ctx.lineWidth = 0.5;
            
            // Horizontal grid lines (y-axis)
            const numHorizontalLines = 5;
            for (let i = 0; i <= numHorizontalLines; i++) {
                const y = margin.top + (chartHeight / numHorizontalLines) * i;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(width - margin.right, y);
                ctx.stroke();
            }
            
            // Vertical grid lines (x-axis)
            const numVerticalLines = Math.min(10, Math.max(1, maxStep - minStep));
            for (let i = 0; i <= numVerticalLines; i++) {
                const x = margin.left + (chartWidth / numVerticalLines) * i;
                ctx.beginPath();
                ctx.moveTo(x, margin.top);
                ctx.lineTo(x, height - margin.bottom);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.beginPath();
            // Y-axis
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, height - margin.bottom);
            // X-axis
            ctx.moveTo(margin.left, height - margin.bottom);
            ctx.lineTo(width - margin.right, height - margin.bottom);
            ctx.stroke();
            
            // Draw lines for each optimizer
            Object.keys(window.comparisonChartsData.gradientMagnitude).forEach(optimizerName => {
                const data = window.comparisonChartsData.gradientMagnitude[optimizerName];
                const optimizer = optimizers[optimizerName];
                const color = optimizer.color;
                
                if (data.length > 1) {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 0.8; // Very thin lines for better clarity
                    ctx.beginPath();
                    
                    data.forEach((point, index) => {
                        const x = margin.left + ((point.step - minStep) / (maxStep - minStep)) * chartWidth;
                        const y = height - margin.bottom - ((point.value - yMin) / (yMax - yMin)) * chartHeight;
                        
                        if (index === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    ctx.stroke();
                }
                
                // Draw data points
                ctx.fillStyle = color;
                data.forEach(point => {
                    const x = margin.left + ((point.step - minStep) / (maxStep - minStep)) * chartWidth;
                    const y = height - margin.bottom - ((point.value - yMin) / (yMax - yMin)) * chartHeight;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 2.5, 0, 2 * Math.PI);
                    ctx.fill();
                });
            });
            
            // Draw labels
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            
            // X-axis label
            ctx.fillText('Optimization Step', width / 2, height - 5);
            
            // Y-axis label
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Gradient Magnitude', 0, 0);
            ctx.restore();
            
            // Y-axis tick labels
            ctx.textAlign = 'right';
            for (let i = 0; i <= numHorizontalLines; i++) {
                const value = yMin + (yMax - yMin) * (1 - i / numHorizontalLines);
                const y = margin.top + (chartHeight / numHorizontalLines) * i;
                ctx.fillText(value.toFixed(3), margin.left - 5, y + 4);
            }
            
            // X-axis tick labels
            ctx.textAlign = 'center';
            for (let i = 0; i <= numVerticalLines; i++) {
                const value = minStep + (maxStep - minStep) * (i / numVerticalLines);
                const x = margin.left + (chartWidth / numVerticalLines) * i;
                ctx.fillText(Math.round(value).toString(), x, height - margin.bottom + 20);
            }
            
            // Update legend
            updateChartLegend('gradient-legend', window.comparisonChartsData.gradientMagnitude);
        }
        
        
        // Toggle fullscreen mode for a view
        function toggleFullscreen(viewType) {
            const container = document.getElementById(`view${viewType}-container`);
            const fullscreenBtn = container.querySelector('.fullscreen-btn');
            const isFullscreen = container.classList.contains('fullscreen');
            
            if (isFullscreen) {
                // Exit fullscreen
                container.classList.remove('fullscreen');
                fullscreenBtn.classList.remove('active');
                fullscreenBtn.textContent = '⛶';
                document.body.style.overflow = 'auto';
                
                // Hide optimizer controls in header (normal mode)
                if (viewType === '2d') {
                    document.getElementById('2d-optimizer-controls').style.display = 'none';
                } else if (viewType === '3d') {
                    document.getElementById('3d-optimizer-controls').style.display = 'none';
                }
                
                // Resize canvas back to normal
                setTimeout(() => {
                    if (viewType === '3d' && gl3d) {
                        // Reset canvas to normal size
                        const canvas3d = document.getElementById('canvas3d');
                        canvas3d.width = 480;
                        canvas3d.height = 400;
                        gl3d.viewport(0, 0, 480, 400);
                        render();
                    } else if (viewType === '2d' && canvas2d) {
                        canvas2d.width = 480;
                        canvas2d.height = 400;
                        
                        // Regenerate contours for normal size
                        generateContours();
                        render2DView();
                    }
                }, 100);
            } else {
                // Enter fullscreen
                container.classList.add('fullscreen');
                fullscreenBtn.classList.add('active');
                fullscreenBtn.textContent = '✕';
                document.body.style.overflow = 'hidden';
                
                // Show optimizer controls in header (fullscreen mode)
                if (viewType === '2d') {
                    document.getElementById('2d-optimizer-controls').style.display = 'flex';
                } else if (viewType === '3d') {
                    document.getElementById('3d-optimizer-controls').style.display = 'flex';
                }
                
                // Resize canvas for fullscreen
                setTimeout(() => {
                    if (viewType === '3d' && gl3d) {
                        // Get actual canvas dimensions
                        const canvas3d = document.getElementById('canvas3d');
                        canvas3d.width = container.clientWidth;
                        canvas3d.height = container.clientHeight - 40; // Account for header
                        gl3d.viewport(0, 0, canvas3d.width, canvas3d.height);
                        render();
                    } else if (viewType === '2d' && canvas2d) {
                        const content = document.getElementById('view2d-content');
                        // Use actual content dimensions for fullscreen
                        canvas2d.width = content.clientWidth - 4; // Account for padding
                        canvas2d.height = content.clientHeight - 4; // Account for padding
                        
                        // Regenerate contours for fullscreen
                        generateContours();
                        render2DView();
                    }
                }, 100);
            }
        }
        
        // Toggle functions container (minimize/expand)
        function toggleFunctionsContainer() {
            const container = document.querySelector('.functions-container');
            const toggleIcon = document.getElementById('toggle-functions-icon');
            
            container.classList.toggle('collapsed');
            
            // Update toggle icon
            if (container.classList.contains('collapsed')) {
                toggleIcon.textContent = '▶';
            } else {
                toggleIcon.textContent = '▼';
            }
            
            // // console.log(`Functions panel ${container.classList.contains('collapsed') ? 'collapsed' : 'expanded'}`);
        }
        
        // 2D View Zoom Functions
        function zoomIn2D() {
            view2dZoom = Math.min(view2dZoom * 1.5, 10.0); // Max 10x zoom
            updateZoomDisplay();
            render2DView();
            // // console.log(`🔍 Zoomed in to ${view2dZoom.toFixed(1)}x`);
        }
        
        function zoomOut2D() {
            view2dZoom = Math.max(view2dZoom / 1.5, 0.1); // Min 0.1x zoom
            updateZoomDisplay();
            render2DView();
            // // console.log(`🔍 Zoomed out to ${view2dZoom.toFixed(1)}x`);
        }
        
        function resetZoom2D() {
            view2dZoom = 1.0;
            view2dCenterX = 0;
            view2dCenterY = 0;
            updateZoomDisplay();
            render2DView();
            // // console.log(`🎯 Zoom reset to 1.0x`);
        }
        
        function updateZoomDisplay() {
            const zoomLevelCompact = document.getElementById('zoom-level-compact');
            zoomLevelCompact.textContent = `${view2dZoom.toFixed(1)}x`;
        }
        
        // Helper function to get zoomed scale
        function getZoomedScale() {
            // Scale to fit parameter space in canvas
            const isFullscreen = document.getElementById('view2d-container').classList.contains('fullscreen');
            if (isFullscreen) {
                // For fullscreen: scale to fit w1w2 range (-8 to 8) in canvas
                const canvas = canvas2d;
                const parameterRange = 16; // -8 to 8 = 16 units
                const scale = Math.min(canvas.width, canvas.height) / parameterRange * 1.2; // 1.2 to fill more space
                return scale * view2dZoom;
            } else {
                // For normal mode, use fixed scale
                return 30 * view2dZoom;
            }
        }
        
        // Helper function to get zoomed range
        function getZoomedRange() {
            return view2dRange / view2dZoom;
        }
        
        // Pan/Move Functions
        function startPan2D(e) {
            if (e.button !== 0) return; // Only left mouse button
            
            isPanning = true;
            panStartX = e.clientX;
            panStartY = e.clientY;
            panStartCenterX = view2dCenterX;
            panStartCenterY = view2dCenterY;
            
            canvas2d.style.cursor = 'grabbing';
            canvas2d.style.userSelect = 'none';
            
            // // console.log('🖱️ Started panning');
        }
        
        function pan2D(e) {
            if (!isPanning) return;
            
            const deltaX = e.clientX - panStartX;
            const deltaY = e.clientY - panStartY;
            
            // Convert pixel movement to parameter space movement
            const scale = getZoomedScale();
            const paramDeltaX = -deltaX / scale; // Negative because we want to move the view opposite to mouse
            const paramDeltaY = deltaY / scale; // Positive because Y is flipped
            
            view2dCenterX = panStartCenterX + paramDeltaX;
            view2dCenterY = panStartCenterY + paramDeltaY;
            
            render2DView();
        }
        
        function endPan2D(e) {
            if (!isPanning) return;
            
            // Check if this was actually a click (small movement) or a drag
            const deltaX = e ? e.clientX - panStartX : 0;
            const deltaY = e ? e.clientY - panStartY : 0;
            const dragDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            isPanning = false;
            canvas2d.style.cursor = 'crosshair';
            canvas2d.style.userSelect = '';
            
            // Only trigger click if movement was small (less than 5 pixels)
            if (dragDistance < 5 && e) {
                handleCanvasClick(e);
            }
            
            // // console.log(`🖱️ Ended panning. New center: (${view2dCenterX.toFixed(2)}, ${view2dCenterY.toFixed(2)})`);
        }
        
        function handleCanvasClick(e) {
            // // console.log('🖱️ 2D Canvas clicked!');
            if (comparisonRunning) {
                // // console.log('❌ Comparison is running, cannot change position');
                alert('Comparison is running! Please stop the comparison first before changing position.');
                return;
            }
            
            const rect = canvas2d.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // // console.log(`Canvas click coordinates: (${x.toFixed(1)}, ${y.toFixed(1)})`);
            
            // Convert canvas coordinates to parameter space coordinates
            const centerX = canvas2d.width / 2;
            const centerY = canvas2d.height / 2;
            const scale = getZoomedScale();
            
            const paramX = (x - centerX) / scale + view2dCenterX;
            const paramY = -(y - centerY) / scale + view2dCenterY; // Flip Y axis
            
            // // console.log(`Parameter space coordinates: (${paramX.toFixed(3)}, ${paramY.toFixed(3)})`);
            
            // Clamp to visualization range
            const clampedX = Math.max(-8, Math.min(8, paramX));
            const clampedY = Math.max(-8, Math.min(8, paramY));
            
            const func = functions[currentFunction];
            const paramZ = func.func(clampedX, clampedY) * func.scale;
            
            // Update all optimizers to the new position
            Object.keys(optimizers).forEach(optimizerName => {
                const optimizer = optimizers[optimizerName];
                optimizer.position = { x: clampedX, y: clampedY, z: paramZ };
                optimizer.path = [];
                optimizer.step = 0;
            });
            
            // // console.log(`🖱️ Click start position: (${clampedX.toFixed(3)}, ${clampedY.toFixed(3)}) → f=${func.func(clampedX, clampedY).toFixed(3)}`);
            // // console.log(`✅ Updated all optimizers to new position`);
            
            // Visual feedback - briefly highlight the click position
            ctx2d.fillStyle = '#2ecc71';
            ctx2d.beginPath();
            ctx2d.arc(x, y, 8, 0, 2 * Math.PI);
            ctx2d.fill();
            
            // Remove highlight after 500ms and re-render
            setTimeout(() => {
                render2DView();
                render();
            }, 500);
        }
        
        // Update optimizers count display
        function updateOptimizersCount() {
            const enabledCount = Object.values(optimizers).filter(opt => opt.enabled).length;
            const totalCount = Object.keys(optimizers).length;
            const countElement = document.getElementById('optimizers-count');
            
            countElement.textContent = `${enabledCount}/${totalCount} enabled`;
        }
        
        // Change optimizer color
        function changeOptimizerColor(optimizerName, color) {
            optimizers[optimizerName].color = color;
            document.getElementById(`${optimizerName}-color`).style.backgroundColor = color;
            // // console.log(`${optimizerName} color changed to ${color}`);
        }
        
        // Update optimizer parameters from UI
        function updateOptimizerParams() {
            // SGD
            optimizers.sgd.params.learningRate = parseFloat(document.getElementById('sgd-lr').value);
            
            // Momentum
            optimizers.momentum.params.learningRate = parseFloat(document.getElementById('momentum-lr').value);
            optimizers.momentum.params.beta = parseFloat(document.getElementById('momentum-beta').value);
            
            // AdaGrad
            optimizers.adagrad.params.learningRate = parseFloat(document.getElementById('adagrad-lr').value);
            optimizers.adagrad.params.epsilon = parseFloat(document.getElementById('adagrad-eps').value);
            
            // Adam
            optimizers.adam.params.learningRate = parseFloat(document.getElementById('adam-lr').value);
            optimizers.adam.params.beta1 = parseFloat(document.getElementById('adam-beta1').value);
            optimizers.adam.params.beta2 = parseFloat(document.getElementById('adam-beta2').value);
            optimizers.adam.params.epsilon = parseFloat(document.getElementById('adam-eps').value);
            
            // RMSprop
            optimizers.rmsprop.params.learningRate = parseFloat(document.getElementById('rmsprop-lr').value);
            optimizers.rmsprop.params.beta = parseFloat(document.getElementById('rmsprop-beta').value);
            optimizers.rmsprop.params.epsilon = parseFloat(document.getElementById('rmsprop-eps').value);
            
            // AdaDelta
            optimizers.adadelta.params.rho = parseFloat(document.getElementById('adadelta-rho').value);
            optimizers.adadelta.params.epsilon = parseFloat(document.getElementById('adadelta-eps').value);
        }
        
        // Get display name for optimizer
        function getOptimizerDisplayName(optimizer) {
            const names = {
                'sgd': 'SGD Algorithm',
                'momentum': 'Momentum Algorithm',
                'adagrad': 'AdaGrad Algorithm',
                'adam': 'Adam Algorithm',
                'rmsprop': 'RMSprop Algorithm',
                'adadelta': 'AdaDelta Algorithm'
            };
            return names[optimizer] || 'Unknown Algorithm';
        }
        
        // Get appropriate slower learning rate for current optimizer
        function getSlowerRate() {
            const currentRate = optimizerParams[currentOptimizer].learningRate;
            const slowerRates = {
                'sgd': 0.0002,
                'momentum': 0.0002,
                'adagrad': 0.01,
                'adam': 0.002,
                'rmsprop': 0.002
            };
            return slowerRates[currentOptimizer] || currentRate * 0.5;
        }
        
        // Get appropriate faster learning rate for current optimizer
        function getFasterRate() {
            const currentRate = optimizerParams[currentOptimizer].learningRate;
            const fasterRates = {
                'sgd': 0.005,
                'momentum': 0.005,
                'adagrad': 0.5,
                'adam': 0.05,
                'rmsprop': 0.05
            };
            return fasterRates[currentOptimizer] || currentRate * 2;
        }

        // Single optimizer step
        function optimizerStep(optimizerName) {
            const optimizer = optimizers[optimizerName];
            if (!optimizer.enabled || optimizer.step >= maxSteps) {
                return;
            }

            // Update parameters from UI
            updateOptimizerParams();

            // Calculate gradient at current position
            const gradient = functions[currentFunction].gradient(optimizer.position.x, optimizer.position.y);
            const functionValue = functions[currentFunction].func(optimizer.position.x, optimizer.position.y);
            
            // Store current position in path BEFORE updating
            optimizer.path.push({
                x: optimizer.position.x,
                y: optimizer.position.y,
                z: optimizer.position.z,
                gradient: gradient,
                step: optimizer.step
            });
            
            const params = optimizer.params;
            let newX = optimizer.position.x;
            let newY = optimizer.position.y;
            
            // Store current state for logging
            const oldState = { ...optimizer.state };
            
            // Apply different optimization algorithms
            switch (optimizerName) {
                case 'sgd':
                    newX -= params.learningRate * gradient.x;
                    newY -= params.learningRate * gradient.y;
                    break;
                    
                case 'momentum':
                    optimizer.state.vx = params.beta * optimizer.state.vx + params.learningRate * gradient.x;
                    optimizer.state.vy = params.beta * optimizer.state.vy + params.learningRate * gradient.y;
                    newX -= optimizer.state.vx;
                    newY -= optimizer.state.vy;
                    break;
                    
                case 'adagrad':
                    optimizer.state.sx += gradient.x * gradient.x;
                    optimizer.state.sy += gradient.y * gradient.y;
                    newX -= params.learningRate * gradient.x / Math.sqrt(optimizer.state.sx + params.epsilon);
                    newY -= params.learningRate * gradient.y / Math.sqrt(optimizer.state.sy + params.epsilon);
                    break;
                    
                case 'adam':
                    optimizer.state.t++;
                    optimizer.state.mx = params.beta1 * optimizer.state.mx + (1 - params.beta1) * gradient.x;
                    optimizer.state.my = params.beta1 * optimizer.state.my + (1 - params.beta1) * gradient.y;
                    optimizer.state.vx = params.beta2 * optimizer.state.vx + (1 - params.beta2) * gradient.x * gradient.x;
                    optimizer.state.vy = params.beta2 * optimizer.state.vy + (1 - params.beta2) * gradient.y * gradient.y;
                    
                    const mHatX = optimizer.state.mx / (1 - Math.pow(params.beta1, optimizer.state.t));
                    const mHatY = optimizer.state.my / (1 - Math.pow(params.beta1, optimizer.state.t));
                    const vHatX = optimizer.state.vx / (1 - Math.pow(params.beta2, optimizer.state.t));
                    const vHatY = optimizer.state.vy / (1 - Math.pow(params.beta2, optimizer.state.t));
                    
                    newX -= params.learningRate * mHatX / (Math.sqrt(vHatX) + params.epsilon);
                    newY -= params.learningRate * mHatY / (Math.sqrt(vHatY) + params.epsilon);
                    break;
                    
                case 'rmsprop':
                    optimizer.state.sx = params.beta * optimizer.state.sx + (1 - params.beta) * gradient.x * gradient.x;
                    optimizer.state.sy = params.beta * optimizer.state.sy + (1 - params.beta) * gradient.y * gradient.y;
                    newX -= params.learningRate * gradient.x / Math.sqrt(optimizer.state.sx + params.epsilon);
                    newY -= params.learningRate * gradient.y / Math.sqrt(optimizer.state.sy + params.epsilon);
                    break;
                    
                case 'adadelta':
                    // AdaDelta: adaptive learning rate without global learning rate
                    optimizer.state.sx = params.rho * optimizer.state.sx + (1 - params.rho) * gradient.x * gradient.x;
                    optimizer.state.sy = params.rho * optimizer.state.sy + (1 - params.rho) * gradient.y * gradient.y;
                    
                    const deltaX = Math.sqrt((optimizer.state.deltaX + params.epsilon) / (optimizer.state.sx + params.epsilon)) * gradient.x;
                    const deltaY = Math.sqrt((optimizer.state.deltaY + params.epsilon) / (optimizer.state.sy + params.epsilon)) * gradient.y;
                    
                    newX -= deltaX;
                    newY -= deltaY;
                    
                    // Update delta accumulators
                    optimizer.state.deltaX = params.rho * optimizer.state.deltaX + (1 - params.rho) * deltaX * deltaX;
                    optimizer.state.deltaY = params.rho * optimizer.state.deltaY + (1 - params.rho) * deltaY * deltaY;
                    break;
            }
            
            // Clamp to visualization range
            newX = Math.max(-8, Math.min(8, newX));
            newY = Math.max(-8, Math.min(8, newY));
            
            const newZ = functions[currentFunction].func(newX, newY) * functions[currentFunction].scale;
            
            // Log detailed calculations if this optimizer is selected for logging
            if (window.selectedLoggingOptimizer === optimizerName) {
                const calculationData = {
                    optimizer: optimizerName,
                    position: { x: optimizer.position.x, y: optimizer.position.y },
                    functionValue: functionValue,
                    gradient: { x: gradient.x, y: gradient.y },
                    params: { ...params },
                    state: { ...oldState },
                    newPosition: { x: newX, y: newY }
                };
                
                // Add optimizer-specific calculation details
                if (optimizerName === 'momentum') {
                    calculationData.newState = { vx: optimizer.state.vx, vy: optimizer.state.vy };
                } else if (optimizerName === 'adagrad') {
                    calculationData.newState = { sx: optimizer.state.sx, sy: optimizer.state.sy };
                } else if (optimizerName === 'adam') {
                    calculationData.newState = { 
                        mx: optimizer.state.mx, my: optimizer.state.my, 
                        vx: optimizer.state.vx, vy: optimizer.state.vy, t: optimizer.state.t 
                    };
                    // Bias correction for Adam
                    const biasCorrected = {
                        mx: optimizer.state.mx / (1 - Math.pow(params.beta1, optimizer.state.t)),
                        my: optimizer.state.my / (1 - Math.pow(params.beta1, optimizer.state.t)),
                        vx: optimizer.state.vx / (1 - Math.pow(params.beta2, optimizer.state.t)),
                        vy: optimizer.state.vy / (1 - Math.pow(params.beta2, optimizer.state.t))
                    };
                    calculationData.biasCorrected = biasCorrected;
                } else if (optimizerName === 'rmsprop') {
                    calculationData.newState = { sx: optimizer.state.sx, sy: optimizer.state.sy };
                } else if (optimizerName === 'adadelta') {
                    calculationData.newState = { 
                        sx: optimizer.state.sx, sy: optimizer.state.sy,
                        deltaX: optimizer.state.deltaX, deltaY: optimizer.state.deltaY 
                    };
                }
                
                window.detailedCalculations.push(calculationData);
                
                // Add gradient magnitude to chart data
                const gradientMagnitude = Math.sqrt(gradient.x * gradient.x + gradient.y * gradient.y);
                
                updateCalculationDisplay();
            }
            
            // Collect data for comparison charts
            if (optimizer.enabled) {
                // Initialize data arrays if not exist
                if (!window.comparisonChartsData.loss[optimizerName]) {
                    window.comparisonChartsData.loss[optimizerName] = [];
                }
                if (!window.comparisonChartsData.gradientMagnitude[optimizerName]) {
                    window.comparisonChartsData.gradientMagnitude[optimizerName] = [];
                }
                
                // Add loss data
                window.comparisonChartsData.loss[optimizerName].push({
                    step: optimizer.step,
                    value: functionValue
                });
                
                // Add gradient magnitude data
                const gradientMagnitude = Math.sqrt(gradient.x * gradient.x + gradient.y * gradient.y);
                window.comparisonChartsData.gradientMagnitude[optimizerName].push({
                    step: optimizer.step,
                    value: gradientMagnitude
                });
                
                // Update charts
                updateLossChart();
                updateGradientMagnitudeChart();
            }
            
            // Update optimizer position
            optimizer.position = { x: newX, y: newY, z: newZ };
            optimizer.step++;
        }
        
        // Check if all enabled optimizers have reached max steps
        function allOptimizersReachedMaxSteps() {
            const enabledOptimizers = Object.keys(optimizers).filter(name => optimizers[name].enabled);
            return enabledOptimizers.every(name => optimizers[name].step >= MAX_STEPS);
        }
        
        // Step all enabled optimizers
        function stepAllOptimizers() {
            Object.keys(optimizers).forEach(optimizerName => {
                if (optimizers[optimizerName].step < MAX_STEPS) {
                    optimizerStep(optimizerName);
                }
            });
        }

        // Comparison Control functions
        function startComparison() {
            if (comparisonRunning) return;
            
            // Check if any optimizer has reached max steps - if so, reset first
            const hasReachedMaxSteps = Object.keys(optimizers).some(name => 
                optimizers[name].enabled && optimizers[name].step >= MAX_STEPS
            );
            
            if (hasReachedMaxSteps) {
                // // console.log('🔄 Previous run completed (400 steps). Resetting for new run...');
                resetComparison();
            }
            
            comparisonRunning = true;
            // // console.log('🚀 Starting multi-optimizer comparison...');
            
            function comparisonLoop() {
                if (comparisonRunning) {
                    stepAllOptimizers();
                    render();
                    
                    // Check if all optimizers have reached max steps
                    if (allOptimizersReachedMaxSteps()) {
                        // // console.log('🏁 All optimizers reached maximum steps (400). Stopping...');
                        stopComparison();
                        return;
                    }
                    
                    comparisonAnimationId = setTimeout(comparisonLoop, 100); // 100ms delay between steps
                }
            }
            comparisonLoop();
        }

        function stopComparison() {
            comparisonRunning = false;
            if (comparisonAnimationId) {
                clearTimeout(comparisonAnimationId);
                comparisonAnimationId = null;
            }
            // // console.log('⏹️ Multi-optimizer comparison stopped');
        }

        function resetComparison() {
            stopComparison();
            
            // Clear comparison charts data
            window.comparisonChartsData = {
                loss: {},
                gradientMagnitude: {}
            };
            clearLossChart();
            clearGradientMagnitudeChart();
            
            // Reset all optimizers
            const func = functions[currentFunction];
            const startPos = func.defaultStart;
            
            Object.keys(optimizers).forEach(optimizerName => {
                const optimizer = optimizers[optimizerName];
                optimizer.path = [];
                optimizer.step = 0;
                optimizer.position = { 
                    x: startPos.x, 
                    y: startPos.y, 
                    z: func.func(startPos.x, startPos.y) * func.scale 
                };
                
                // Reset optimizer states
                switch (optimizerName) {
                    case 'momentum':
                        optimizer.state = { vx: 0, vy: 0 };
                        break;
                    case 'adagrad':
                        optimizer.state = { sx: 0, sy: 0 };
                        break;
                    case 'adam':
                        optimizer.state = { mx: 0, my: 0, vx: 0, vy: 0, t: 0 };
                        break;
                    case 'rmsprop':
                        optimizer.state = { sx: 0, sy: 0 };
                        break;
                    case 'adadelta':
                        optimizer.state = { sx: 0, sy: 0, deltaX: 0, deltaY: 0 };
                        break;
                    default:
                        optimizer.state = {};
                }
            });
            
            // // console.log('🔄 All optimizers reset to starting position');
            render();
        }

        function stepComparison() {
            if (!comparisonRunning) {
                // Check if any optimizer has reached max steps
                const hasReachedMaxSteps = Object.keys(optimizers).some(name => 
                    optimizers[name].enabled && optimizers[name].step >= MAX_STEPS
                );
                
                if (hasReachedMaxSteps) {
                    // // console.log('🏁 All optimizers reached maximum steps (400). Please reset or start new run.');
                    return;
                }
                
                stepAllOptimizers();
                render();
            }
        }
        
        function randomStartComparison() {
            stopComparison();
            
            // Random position within the visualization range (-8 to 8)
            const x = (Math.random() - 0.5) * 16; // -8 to 8
            const y = (Math.random() - 0.5) * 16; // -8 to 8
            const z = functions[currentFunction].func(x, y) * functions[currentFunction].scale;
            
            Object.keys(optimizers).forEach(optimizerName => {
                const optimizer = optimizers[optimizerName];
                optimizer.position = { x, y, z };
                optimizer.path = [];
                optimizer.step = 0;
            });
            
            // // console.log('🎲 Random start position set for all optimizers:', { x, y, z });
            render();
        }

        function adjustLearningRate(newRate) {
            optimizerParams[currentOptimizer].learningRate = newRate;
            // // console.log(`${currentOptimizer.toUpperCase()} learning rate adjusted to: ${newRate}`);
        }

        function randomStart() {
            stopOptimizer();
            // Random position within the visualization range (-8 to 8)
            const x = (Math.random() - 0.5) * 16; // -8 to 8
            const y = (Math.random() - 0.5) * 16; // -8 to 8
            const z = functions[currentFunction].func(x, y) * functions[currentFunction].scale;
            
            currentPosition = { x: x, y: y, z: z };
            sgdPath = [];
            currentStep = 0;
            
            // // console.log(`🎲 Random start position: (${x.toFixed(3)}, ${y.toFixed(3)}) → f=${functions[currentFunction].func(x, y).toFixed(3)}`);
        }

        function testClick() {
            // // console.log('🖱️ Testing click functionality...');
            // // console.log('Canvas2d element:', canvas2d);
            // // console.log('Canvas2d dimensions:', canvas2d.width, 'x', canvas2d.height);
            // // console.log('Event listeners attached:', canvas2d.onclick !== null);
            
            // Simulate a click at center
            const centerX = canvas2d.width / 2;
            const centerY = canvas2d.height / 2;
            // // console.log(`Simulating click at canvas center: (${centerX}, ${centerY})`);
            
            // Test coordinate conversion
            const scale = 30;
            const paramX = (centerX - centerX) / scale; // Should be 0
            const paramY = -(centerY - centerY) / scale; // Should be 0
            // // console.log(`Converted to parameter space: (${paramX}, ${paramY})`);
        }

        // Generate minima markers for the current function
        function generateMinimaMarkers() {
            const func = functions[currentFunction];
            let minima = [];
            
            // Define minima for each function
            if (currentFunction === 'himmelblau') {
                minima = [[3, 2], [-2.805118, 3.131312], [-3.779310, -3.283186], [3.584428, -1.848126]]; // 4 minima
            } else if (currentFunction === 'rosenbrock') {
                minima = [[1, 1]]; // 1 minimum
            } else if (currentFunction === 'quadratic') {
                minima = [[0, 0]]; // 1 minimum
            } else if (currentFunction === 'booth') {
                minima = [[1, 3]]; // 1 minimum
            }
            
            const markerVertices = [];
            const markerNormals = [];
            
            // Create small spheres at each minima
            for (const [x, y] of minima) {
                const z = func.func(x, y) * func.scale;
                
                // Create a small sphere (8 vertices for simplicity)
                const radius = 0.3;
                const segments = 8;
                
                for (let i = 0; i < segments; i++) {
                    const angle1 = (i * 2 * Math.PI) / segments;
                    const angle2 = ((i + 1) * 2 * Math.PI) / segments;
                    
                    // Center point
                    markerVertices.push(x, y, z);
                    markerNormals.push(0, 0, 1);
                    
                    // First edge point
                    markerVertices.push(
                        x + radius * Math.cos(angle1),
                        y + radius * Math.sin(angle1),
                        z
                    );
                    markerNormals.push(0, 0, 1);
                    
                    // Second edge point
                    markerVertices.push(
                        x + radius * Math.cos(angle2),
                        y + radius * Math.sin(angle2),
                        z
                    );
                    markerNormals.push(0, 0, 1);
                }
            }
            
            // // console.log(`✅ Generated ${markerVertices.length/3} minima marker vertices`);
            return { vertices: markerVertices, normals: markerNormals };
        }

        // Color mapping function for contour levels using user-defined colors
        function getContourColor(level, minLevel, maxLevel) {
            // Normalize level to 0-1 range
            const normalized = (level - minLevel) / (maxLevel - minLevel);
            
            // Get user-defined colors (default if not set)
            const coldColor = window.coldColor || '#ff4444';
            const hotColor = window.hotColor || '#4444ff';
            
            // Convert hex colors to RGB
            function hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }
            
            const coldRgb = hexToRgb(coldColor);
            const hotRgb = hexToRgb(hotColor);
            
            // Interpolate between cold and hot colors
            const r = Math.floor(coldRgb.r + (hotRgb.r - coldRgb.r) * normalized);
            const g = Math.floor(coldRgb.g + (hotRgb.g - coldRgb.g) * normalized);
            const b = Math.floor(coldRgb.b + (hotRgb.b - coldRgb.b) * normalized);
            
            return `rgb(${r}, ${g}, ${b})`;
        }

        // Generate contour lines using marching squares algorithm
        function generateContours(range = 8, resolution = 64, contourLevels = 10, customLevels = null) {
            const step = (range * 2) / (resolution - 1);
            const func = functions[currentFunction];
            const scale = func.scale;
            
            // Create grid of function values
            const grid = [];
            let minValue = Infinity;
            let maxValue = -Infinity;
            
            for (let row = 0; row < resolution; row++) {
                grid[row] = [];
                for (let col = 0; col < resolution; col++) {
                    const x = -range + col * step;
                    const y = -range + row * step;
                    grid[row][col] = func.func(x, y) * scale;
                }
            }
            
            // Calculate min/max values
            for (let row = 0; row < resolution; row++) {
                for (let col = 0; col < resolution; col++) {
                    minValue = Math.min(minValue, grid[row][col]);
                    maxValue = Math.max(maxValue, grid[row][col]);
                }
            }
            
            // Create contour levels
            let levels = [];
            if (customLevels) {
                // Use custom levels if provided
                levels = customLevels;
                // // console.log(`🎯 Using custom levels for ${currentFunction}:`, levels);
            } else {
                // Default linear distribution
                const stepLevel = (maxValue - minValue) / contourLevels;
                for (let i = 0; i <= contourLevels; i++) {
                    levels.push(minValue + i * stepLevel);
                }
                // // console.log(`📊 Using linear levels for ${currentFunction}:`, levels.length, 'levels');
            }
            
            const contourVertices = [];
            const contourColors = [];
            
            // Find min/max levels for color mapping
            const minLevel = Math.min(...levels);
            const maxLevel = Math.max(...levels);
            
            // Marching squares for each level
            for (const level of levels) {
                for (let row = 0; row < resolution - 1; row++) {
                    for (let col = 0; col < resolution - 1; col++) {
                        // Get corner values
                        const v1 = grid[row][col];         // top-left
                        const v2 = grid[row][col + 1];     // top-right
                        const v3 = grid[row + 1][col + 1]; // bottom-right
                        const v4 = grid[row + 1][col];     // bottom-left
                        
                        // Get corner positions
                        const x1 = -range + col * step;
                        const y1 = -range + row * step;
                        const x2 = -range + (col + 1) * step;
                        const y2 = -range + (row + 1) * step;
                        
                        // Calculate intersection points
                        const points = [];
                        
                        // Edge 1: top edge (v1 to v2)
                        if ((v1 <= level && v2 > level) || (v1 > level && v2 <= level)) {
                            const t = (level - v1) / (v2 - v1);
                            points.push([x1 + t * (x2 - x1), y1, 0]); // Project to z=0 plane
                        }
                        
                        // Edge 2: right edge (v2 to v3)
                        if ((v2 <= level && v3 > level) || (v2 > level && v3 <= level)) {
                            const t = (level - v2) / (v3 - v2);
                            points.push([x2, y1 + t * (y2 - y1), 0]); // Project to z=0 plane
                        }
                        
                        // Edge 3: bottom edge (v3 to v4)
                        if ((v3 <= level && v4 > level) || (v3 > level && v4 <= level)) {
                            const t = (level - v3) / (v4 - v3);
                            points.push([x2 - t * (x2 - x1), y2, 0]); // Project to z=0 plane
                        }
                        
                        // Edge 4: left edge (v4 to v1)
                        if ((v4 <= level && v1 > level) || (v4 > level && v1 <= level)) {
                            const t = (level - v4) / (v1 - v4);
                            points.push([x1, y2 - t * (y2 - y1), 0]); // Project to z=0 plane
                        }
                        
                        // Add line segments with color
                        if (points.length >= 2) {
                            const color = getContourColor(level, minLevel, maxLevel);
                            
                            // Add first line
                            contourVertices.push(
                                points[0][0], points[0][1], points[0][2],
                                points[1][0], points[1][1], points[1][2]
                            );
                            contourColors.push(color, color); // Color for both endpoints
                            
                            // Add second line if we have 4 points (ambiguous case)
                            if (points.length === 4) {
                                contourVertices.push(
                                    points[2][0], points[2][1], points[2][2],
                                    points[3][0], points[3][1], points[3][2]
                                );
                                contourColors.push(color, color); // Color for both endpoints
                            }
                        }
                    }
                }
            }
            
            // // console.log(`✅ Generated ${contourVertices.length / 6} contour line segments with colors`);
            return { vertices: contourVertices, colors: contourColors };
        }


        // Vertex shader with Phong shading
        const vertexShaderSource = `
            attribute vec3 position;
            attribute vec3 normal;
            attribute vec3 color;
            uniform mat4 modelViewMatrix;
            uniform mat4 projectionMatrix;
            uniform mat3 normalMatrix;
            varying vec3 vColor;
            varying vec3 vNormal;
            varying vec3 vPosition;
            
            void main() {
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                vNormal = normalize(normalMatrix * normal);
                vPosition = vec3(modelViewMatrix * vec4(position, 1.0));
                vColor = color;
            }
        `;

        // Fragment shader with debug mode and lighting modes
        const fragmentShaderSource = `
            precision mediump float;
            varying vec3 vNormal;
            varying vec3 vPosition;
            varying vec3 vColor;
            uniform bool debugMode;
            uniform bool enhancedLighting;
            uniform bool wireframeMode;
            uniform bool contourMode;
            uniform bool minimaMode;
            uniform bool optimizerMode;
            uniform vec3 optimizerColor;
            
            void main() {
                if (debugMode) {
                    // Debug mode: show normals as colors
                    vec3 normal = normalize(vNormal);
                    gl_FragColor = vec4(normal * 0.5 + 0.5, 1.0);
                } else if (contourMode) {
                    // Contour mode - gradient from blue to orange-red based on distance from center
                    float distance = sqrt(vPosition.x * vPosition.x + vPosition.y * vPosition.y);
                    float normalizedDist = clamp(distance / 8.0, 0.0, 1.0);
                    
                    vec3 contourColor;
                    if (normalizedDist < 0.5) {
                        // Blue to cyan for inner contours (near minima)
                        contourColor = mix(vec3(0.2, 0.4, 1.0), vec3(0.3, 0.8, 1.0), normalizedDist * 2.0);
                    } else {
                        // Cyan to orange-red for outer contours (away from minima)
                        contourColor = mix(vec3(0.3, 0.8, 1.0), vec3(1.0, 0.5, 0.2), (normalizedDist - 0.5) * 2.0);
                    }
                    gl_FragColor = vec4(contourColor, 1.0);
                } else if (minimaMode) {
                    // Minima markers - bright red
                    vec3 minimaColor = vec3(1.0, 0.1, 0.1); // Bright red
                    gl_FragColor = vec4(minimaColor, 1.0);
                } else if (optimizerMode) {
                    // Optimizer markers - use individual optimizer colors
                    gl_FragColor = vec4(optimizerColor, 1.0);
                } else if (wireframeMode) {
                    // Wireframe mode - use interpolated colors from vertices
                    vec3 baseColor = vColor;
                    
                    // Make wireframe darker for better visibility
                    vec3 wireColor = baseColor * 0.7; // Darker version of interpolated color
                    gl_FragColor = vec4(wireColor, 1.0);
                } else if (enhancedLighting) {
                    // Color interpolation with lighting
                    vec3 baseColor = vColor;
                    
                    // Simple lighting
                    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                    vec3 normal = normalize(vNormal);
                    float diff = max(dot(normal, lightDir), 0.0);
                    
                    vec3 ambient = vec3(0.3, 0.3, 0.4);
                    vec3 diffuse = diff * baseColor;
                    
                    vec3 result = ambient + diffuse;
                    gl_FragColor = vec4(result, 1.0);
                } else {
                    // Simple lighting mode with color interpolation
                    vec3 baseColor = vColor;
                    
                    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                    vec3 ambient = vec3(0.4, 0.4, 0.5);
                    
                    vec3 normal = normalize(vNormal);
                    float diff = max(dot(normal, lightDir), 0.0);
                    
                    vec3 diffuse = diff * baseColor;
                    vec3 result = ambient + diffuse;
                    gl_FragColor = vec4(result, 1.0);
                }
            }
        `;

        function initWebGL() {
            // Initialize 3D canvas
            canvas3d = document.getElementById('canvas3d');
            gl3d = canvas3d.getContext('webgl') || canvas3d.getContext('experimental-webgl');
            // Initialize 2D canvas with 2D context
            canvas2d = document.getElementById('canvas2d');
            ctx2d = canvas2d.getContext('2d');
            
            if (!gl3d || !ctx2d) {
                alert('WebGL or Canvas 2D not supported');
                return false;
            }

            // Debug: Check if canvas2d is properly initialized
            // // console.log('Canvas2d element:', canvas2d);
            // // console.log('Canvas2d dimensions:', canvas2d.width, 'x', canvas2d.height);
            // // console.log('Canvas2d position:', canvas2d.getBoundingClientRect());
            // // console.log('Canvas2d style:', window.getComputedStyle(canvas2d));

            // // console.log('✅ WebGL and Canvas 2D initialized successfully');

            // Test click event immediately
            canvas2d.addEventListener('click', (e) => {
                // // console.log('🧪 TEST: Canvas2d click event triggered!');
            });

            // Create shader program for 3D
            program3d = createShaderProgram(gl3d, vertexShaderSource, fragmentShaderSource);
            
            if (!program3d) {
                console.error('❌ Failed to create 3D shader program');
                return false;
            }

            // Setup 3D context
            gl3d.useProgram(program3d);
            gl3d.enable(gl3d.DEPTH_TEST);
            gl3d.disable(gl3d.CULL_FACE);

            // Create current function surface data
            createCurrentFunctionSurface();

            // Initialize SGD starting position
            resetComparison();
            
            // Test SGD immediately
            // // console.log('Testing SGD step...');
            stepComparison();
            
            // Force initial render
            render();

            // Set up mouse controls
            setupMouseControls();

            // Start render loop
            requestAnimationFrame(render);
            
            // Initialize optimizers count display
            updateOptimizersCount();
            
            // Initialize function parameters and add change listeners
            initializeFunctionParameters();
            
            return true;
        }

        function createShaderProgram(gl, vertexSource, fragmentSource) {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);

            if (!vertexShader || !fragmentShader) {
                return null;
            }

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('❌ Error linking program:', gl.getProgramInfoLog(program));
                return null;
            }

            // // console.log('✅ Shader program created successfully');
            return program;
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('❌ Error compiling shader:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }

            return shader;
        }

        function createCurrentFunctionSurface() {
            const range = 8; // Expanded from 6 to 8 for wider view
            const resolution = 60; // Lower resolution for less dense triangles (easier to see paths)
            const step = (range * 2) / (resolution - 1);
            const func = functions[currentFunction];
            const scale = func.scale;
            
            const vertices = [];
            const normals = [];
            const colors = [];
            const wireframeVertices = [];
            const wireframeNormals = [];
            const wireframeColors = [];
            const contourVertices = [];
            const minimaMarkers = [];

            // // console.log(`✅ Creating ${func.name} surface: ${resolution}x${resolution} grid`);

            // Calculate min/max height for color mapping
            let minHeight = Infinity;
            let maxHeight = -Infinity;
            
            for (let row = 0; row < resolution; row++) {
                for (let col = 0; col < resolution; col++) {
                    const x = -range + col * step;
                    const y = -range + row * step;
                    const z = func.func(x, y) * scale;
                    minHeight = Math.min(minHeight, z);
                    maxHeight = Math.max(maxHeight, z);
                }
            }
            
            // Ensure valid range
            if (minHeight === Infinity) minHeight = 0;
            if (maxHeight === -Infinity) maxHeight = 1;
            if (minHeight === maxHeight) maxHeight = minHeight + 1;
            
            // // console.log(`Height range: ${minHeight.toFixed(3)} to ${maxHeight.toFixed(3)}`);

            // Function to map height to color using user-defined colors
            function heightToColor(height) {
                const normalizedHeight = (height - minHeight) / (maxHeight - minHeight);
                
                // Get user-defined colors (default if not set)
                const coldColor = window.coldColor || '#ff4444';
                const hotColor = window.hotColor || '#4444ff';
                
                // Convert hex colors to RGB (0-1 range)
                function hexToRgb01(hex) {
                    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    return result ? {
                        r: parseInt(result[1], 16) / 255,
                        g: parseInt(result[2], 16) / 255,
                        b: parseInt(result[3], 16) / 255
                    } : null;
                }
                
                const coldRgb = hexToRgb01(coldColor);
                const hotRgb = hexToRgb01(hotColor);
                
                // Interpolate between cold and hot colors
                return {
                    r: coldRgb.r + (hotRgb.r - coldRgb.r) * normalizedHeight,
                    g: coldRgb.g + (hotRgb.g - coldRgb.g) * normalizedHeight,
                    b: coldRgb.b + (hotRgb.b - coldRgb.b) * normalizedHeight
                };
            }

            // First, create a 2D grid of vertices
            const gridVertices = [];
            const gridNormals = [];
            const gridColors = [];
            
            for (let row = 0; row < resolution; row++) {
                for (let col = 0; col < resolution; col++) {
                    const x = -range + col * step;
                    const y = -range + row * step;
                    const z = func.func(x, y) * scale;
                    
                    gridVertices.push(x, y, z);
                    
                    // Calculate color based on height
                    const color = heightToColor(z);
                    gridColors.push(color.r, color.g, color.b);
                }
            }
            
            // Calculate normals by averaging adjacent triangle normals
            for (let row = 0; row < resolution; row++) {
                for (let col = 0; col < resolution; col++) {
                    const normal = calculateTriangleBasedNormal(row, col, gridVertices, resolution, range, step, scale);
                    gridNormals.push(normal.x, normal.y, normal.z);
                }
            }

            // Generate individual triangles instead of triangle strips for better normal consistency
            for (let row = 0; row < resolution - 1; row++) {
                for (let col = 0; col < resolution - 1; col++) {
                    // Get four vertices of a quad
                    const idx1 = row * resolution + col;           // top-left
                    const idx2 = row * resolution + (col + 1);     // top-right
                    const idx3 = (row + 1) * resolution + col;     // bottom-left
                    const idx4 = (row + 1) * resolution + (col + 1); // bottom-right
                    
                    // Triangle 1: counter-clockwise winding (top-left → top-right → bottom-left)
                    vertices.push(
                        gridVertices[idx1 * 3], gridVertices[idx1 * 3 + 1], gridVertices[idx1 * 3 + 2],
                        gridVertices[idx2 * 3], gridVertices[idx2 * 3 + 1], gridVertices[idx2 * 3 + 2],
                        gridVertices[idx3 * 3], gridVertices[idx3 * 3 + 1], gridVertices[idx3 * 3 + 2]
                    );
                    
                    normals.push(
                        gridNormals[idx1 * 3], gridNormals[idx1 * 3 + 1], gridNormals[idx1 * 3 + 2],
                        gridNormals[idx2 * 3], gridNormals[idx2 * 3 + 1], gridNormals[idx2 * 3 + 2],
                        gridNormals[idx3 * 3], gridNormals[idx3 * 3 + 1], gridNormals[idx3 * 3 + 2]
                    );
                    
                    colors.push(
                        gridColors[idx1 * 3], gridColors[idx1 * 3 + 1], gridColors[idx1 * 3 + 2],
                        gridColors[idx2 * 3], gridColors[idx2 * 3 + 1], gridColors[idx2 * 3 + 2],
                        gridColors[idx3 * 3], gridColors[idx3 * 3 + 1], gridColors[idx3 * 3 + 2]
                    );
                    
                    // Triangle 2: counter-clockwise winding (top-right → bottom-right → bottom-left)
                    vertices.push(
                        gridVertices[idx2 * 3], gridVertices[idx2 * 3 + 1], gridVertices[idx2 * 3 + 2],
                        gridVertices[idx4 * 3], gridVertices[idx4 * 3 + 1], gridVertices[idx4 * 3 + 2],
                        gridVertices[idx3 * 3], gridVertices[idx3 * 3 + 1], gridVertices[idx3 * 3 + 2]
                    );
                    
                    normals.push(
                        gridNormals[idx2 * 3], gridNormals[idx2 * 3 + 1], gridNormals[idx2 * 3 + 2],
                        gridNormals[idx4 * 3], gridNormals[idx4 * 3 + 1], gridNormals[idx4 * 3 + 2],
                        gridNormals[idx3 * 3], gridNormals[idx3 * 3 + 1], gridNormals[idx3 * 3 + 2]
                    );
                    
                    colors.push(
                        gridColors[idx2 * 3], gridColors[idx2 * 3 + 1], gridColors[idx2 * 3 + 2],
                        gridColors[idx4 * 3], gridColors[idx4 * 3 + 1], gridColors[idx4 * 3 + 2],
                        gridColors[idx3 * 3], gridColors[idx3 * 3 + 1], gridColors[idx3 * 3 + 2]
                    );
                }
            }

            // Generate wireframe vertices (all edges)
            for (let row = 0; row < resolution - 1; row++) {
                for (let col = 0; col < resolution - 1; col++) {
                    const x1 = -range + col * step;
                    const x2 = -range + (col + 1) * step;
                    const y1 = -range + row * step;
                    const y2 = -range + (row + 1) * step;
                    
                    const z11 = func.func(x1, y1) * scale;
                    const z12 = func.func(x1, y2) * scale;
                    const z21 = func.func(x2, y1) * scale;
                    const z22 = func.func(x2, y2) * scale;
                    
                    // Triangle 1 edges
                    wireframeVertices.push(x1, y1, z11, x1, y2, z12); // left edge
                    wireframeVertices.push(x1, y2, z12, x2, y1, z21); // diagonal edge
                    wireframeVertices.push(x2, y1, z21, x1, y1, z11); // bottom edge
                    
                    // Triangle 2 edges
                    wireframeVertices.push(x1, y2, z12, x2, y2, z22); // top edge
                    wireframeVertices.push(x2, y2, z22, x2, y1, z21); // right edge
                    
                    // Add colors for wireframe (interpolate between vertices)
                    const color11 = heightToColor(z11);
                    const color12 = heightToColor(z12);
                    const color21 = heightToColor(z21);
                    const color22 = heightToColor(z22);
                    
                    // Triangle 1 edges
                    wireframeColors.push(color11.r, color11.g, color11.b, color12.r, color12.g, color12.b); // left edge
                    wireframeColors.push(color12.r, color12.g, color12.b, color21.r, color21.g, color21.b); // diagonal edge
                    wireframeColors.push(color21.r, color21.g, color21.b, color11.r, color11.g, color11.b); // bottom edge
                    
                    // Triangle 2 edges
                    wireframeColors.push(color12.r, color12.g, color12.b, color22.r, color22.g, color22.b); // top edge
                    wireframeColors.push(color22.r, color22.g, color22.b, color21.r, color21.g, color21.b); // right edge
                    
                    // Add normals for wireframe
                    for (let i = 0; i < 10; i++) { // 5 edges * 2 vertices
                        const normal = calculateNormal(x1, y1, range, step, scale);
                        wireframeNormals.push(normal.x, normal.y, normal.z);
                    }
                }
            }

            // Generate contour lines with function-specific levels
            let contourData;
            if (currentFunction === 'himmelblau') {
                // Custom levels for Himmelblau function
                const himmelblauLevels = [0, 0.5, 1, 2, 3, 4, 5, 7, 10, 15, 20, 30, 40, 50, 70, 100, 150, 200];
                contourData = generateContours(range, resolution, 40, himmelblauLevels);
            } else if (currentFunction === 'rosenbrock') {
                // Hybrid levels for Rosenbrock function: log-scale (small) + linear (medium + big)
                // levels_small = np.logspace(-6, -1, 10)     # 1e-6 → 1e-1 (ellipse quanh (1,1))
                // levels_med   = np.linspace(0.2, 20, 12)    # 0.2 → 20 (bên trong thung lũng)
                // levels_big   = np.linspace(30, 500, 10)    # 30 → 500 (viền xa)
                const levelsSmall = [0.000001, 0.000002, 0.000005, 0.00001, 0.00002, 0.00005, 0.0001, 0.0002, 0.0005, 0.001, 0.002, 0.005, 0.01, 0.02, 0.05, 0.1]; // log-scale
                const levelsMed = [0.2, 1.8, 3.4, 5, 6.6, 8.2, 9.8, 11.4, 13, 14.6, 16.2, 17.8, 19.4]; // linear 0.2-20
                const levelsBig = [30, 82, 134, 186, 238, 290, 342, 394, 446, 498]; // linear 30-500
                const rosenbrockLevels = [...levelsSmall, ...levelsMed, ...levelsBig];
                contourData = generateContours(range, resolution, 40, rosenbrockLevels);
            } else if (currentFunction === 'booth') {
                // Log scale levels for Booth function
                // np.logspace(-2, 3.5, 60) = từ 1e-2 → ~3000 (60 levels)
                const boothLevels = [];
                for (let i = 0; i < 60; i++) {
                    const logValue = -2 + (i * (3.5 - (-2)) / (60 - 1));
                    boothLevels.push(Math.pow(10, logValue));
                }
                contourData = generateContours(range, resolution, 40, boothLevels);
            } else if (currentFunction === 'quadratic') {
                // Custom levels for Quadratic Bowl function
                const quadraticLevels = [0, 1, 2, 5, 10, 20, 40, 60, 80, 100, 150, 200];
                contourData = generateContours(range, resolution, 40, quadraticLevels);
            } else {
                // Default linear levels for other functions
                contourData = generateContours(range, resolution, 40);
            }
            // // console.log('🔍 Generated contour data:', contourData.vertices.length, 'points with', contourData.colors.length, 'colors');
            contourVertices.push(...contourData.vertices);
            window.contourColors = contourData.colors; // Store colors for 2D rendering

            // Generate minima markers
            const minimaData = generateMinimaMarkers(scale);
            minimaMarkers.push(...minimaData.vertices);

            // // console.log(`✅ Generated ${vertices.length/3} solid vertices (individual triangles)`);
            // // console.log(`✅ Generated ${wireframeVertices.length/3} wireframe vertices`);
            // // console.log(`✅ Generated ${contourVertices.length/3} contour vertices`);
            // // console.log(`✅ Generated ${minimaMarkers.length/3} minima marker vertices`);

            // Create buffers for 3D program
            const vertexBuffer3d = gl3d.createBuffer();
            gl3d.bindBuffer(gl3d.ARRAY_BUFFER, vertexBuffer3d);
            gl3d.bufferData(gl3d.ARRAY_BUFFER, new Float32Array(vertices), gl3d.STATIC_DRAW);

            const normalBuffer3d = gl3d.createBuffer();
            gl3d.bindBuffer(gl3d.ARRAY_BUFFER, normalBuffer3d);
            gl3d.bufferData(gl3d.ARRAY_BUFFER, new Float32Array(normals), gl3d.STATIC_DRAW);

            const colorBuffer3d = gl3d.createBuffer();
            gl3d.bindBuffer(gl3d.ARRAY_BUFFER, colorBuffer3d);
            gl3d.bufferData(gl3d.ARRAY_BUFFER, new Float32Array(colors), gl3d.STATIC_DRAW);

            const wireframeVertexBuffer3d = gl3d.createBuffer();
            gl3d.bindBuffer(gl3d.ARRAY_BUFFER, wireframeVertexBuffer3d);
            gl3d.bufferData(gl3d.ARRAY_BUFFER, new Float32Array(wireframeVertices), gl3d.STATIC_DRAW);

            const wireframeNormalBuffer3d = gl3d.createBuffer();
            gl3d.bindBuffer(gl3d.ARRAY_BUFFER, wireframeNormalBuffer3d);
            gl3d.bufferData(gl3d.ARRAY_BUFFER, new Float32Array(wireframeNormals), gl3d.STATIC_DRAW);

            const wireframeColorBuffer3d = gl3d.createBuffer();
            gl3d.bindBuffer(gl3d.ARRAY_BUFFER, wireframeColorBuffer3d);
            gl3d.bufferData(gl3d.ARRAY_BUFFER, new Float32Array(wireframeColors), gl3d.STATIC_DRAW);

            const minimaVertexBuffer3d = gl3d.createBuffer();
            gl3d.bindBuffer(gl3d.ARRAY_BUFFER, minimaVertexBuffer3d);
            gl3d.bufferData(gl3d.ARRAY_BUFFER, new Float32Array(minimaMarkers), gl3d.STATIC_DRAW);

            const minimaNormals = [];
            for (let i = 0; i < minimaMarkers.length / 3; i++) {
                minimaNormals.push(0, 0, 1);
            }
            const minimaNormalBuffer3d = gl3d.createBuffer();
            gl3d.bindBuffer(gl3d.ARRAY_BUFFER, minimaNormalBuffer3d);
            gl3d.bufferData(gl3d.ARRAY_BUFFER, new Float32Array(minimaNormals), gl3d.STATIC_DRAW);

            // Store contour data for 2D canvas rendering
            window.contourData = contourVertices;
            // // console.log('🔍 Stored window.contourData:', window.contourData.length, 'points');

            // Store references for 3D program
            program3d.vertexBuffer = vertexBuffer3d;
            program3d.normalBuffer = normalBuffer3d;
            program3d.colorBuffer = colorBuffer3d;
            program3d.wireframeVertexBuffer = wireframeVertexBuffer3d;
            program3d.wireframeNormalBuffer = wireframeNormalBuffer3d;
            program3d.wireframeColorBuffer = wireframeColorBuffer3d;
            program3d.minimaVertexBuffer = minimaVertexBuffer3d;
            program3d.minimaNormalBuffer = minimaNormalBuffer3d;
            program3d.numVertices = vertices.length / 3;
            program3d.wireframeNumVertices = wireframeVertices.length / 3;
            program3d.minimaNumVertices = minimaMarkers.length / 3;

            // // console.log(`✅ Contour data: ${contourVertices.length / 3} contour vertices stored for 2D rendering`);
        }

        function calculateTriangleBasedNormal(row, col, gridVertices, resolution, range, step, scale) {
            // Simplified approach: calculate normal from immediate neighbors only
            const idx = row * resolution + col;
            const x = -range + col * step;
            const y = -range + row * step;
            
            // Use finite differences with proper step size
            const eps = step;
            
            // Get neighboring points
            let x1 = x - eps, x2 = x + eps, y1 = y - eps, y2 = y + eps;
            
            // Clamp to bounds
            x1 = Math.max(-range, x1);
            x2 = Math.min(range, x2);
            y1 = Math.max(-range, y1);
            y2 = Math.min(range, y2);
            
            // Calculate partial derivatives
            const currentFunc = functions[currentFunction];
            const z_center = currentFunc.func(x, y) * scale;
            const z_x1 = currentFunc.func(x1, y) * scale;
            const z_x2 = currentFunc.func(x2, y) * scale;
            const z_y1 = currentFunc.func(x, y1) * scale;
            const z_y2 = currentFunc.func(x, y2) * scale;
            
            const dx = (z_x2 - z_x1) / (x2 - x1);
            const dy = (z_y2 - z_y1) / (y2 - y1);
            
            // Normal vector (consistent direction)
            const nx = -dx;
            const ny = -dy;
            const nz = 1.0;
            
            // Normalize
            const length = Math.sqrt(nx*nx + ny*ny + nz*nz);
            if (length < 1e-6) {
                return { x: 0, y: 0, z: 1 };
            }
            
            const normal = {
                x: nx / length,
                y: ny / length,
                z: nz / length
            };
            
            // Ensure consistent direction (always pointing up)
            if (normal.z < 0) {
                normal.x = -normal.x;
                normal.y = -normal.y;
                normal.z = -normal.z;
            }
            
            return normal;
        }

        function calculateNormal(x, y, range, step, scale) {
            // Legacy function for wireframe - simpler calculation
            const eps = 0.1;
            const currentFunc = functions[currentFunction];
            const z = currentFunc.func(x, y) * scale;
            const zx = currentFunc.func(x + eps, y) * scale;
            const zy = currentFunc.func(x, y + eps) * scale;
            
            const dx = (zx - z) / eps;
            const dy = (zy - z) / eps;
            
            const nx = -dx;
            const ny = -dy;
            const nz = 1.0;
            
            const length = Math.sqrt(nx*nx + ny*ny + nz*nz);
            if (length < 0.0001) {
                return { x: 0, y: 0, z: 1 };
            }
            
            return {
                x: nx / length,
                y: ny / length,
                z: nz / length
            };
        }

        function setupMouseControls() {
            // Only 3D canvas responds to mouse controls
            canvas3d.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            canvas3d.addEventListener('mousemove', (e) => {
                if (isMouseDown) {
                    const deltaX = e.clientX - mouseX;
                    const deltaY = e.clientY - mouseY;
                    
                    rotationY += deltaX * 0.01;
                    rotationX += deltaY * 0.01;
                    
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                }
            });

            canvas3d.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            canvas3d.addEventListener('wheel', (e) => {
                e.preventDefault();
                zoom *= (1 - e.deltaY * 0.001);
                zoom = Math.max(0.3, Math.min(2, zoom)); // Adjusted zoom range for new camera distance
            });

            // Click functionality is now handled in handleCanvasClick() via pan events

            // Make sure canvas is clickable
            canvas2d.style.cursor = 'crosshair';
            
            // Add mouse wheel zoom support
            canvas2d.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                const delta = e.deltaY > 0 ? -1 : 1; // Scroll down = zoom out, scroll up = zoom in
                const zoomFactor = 1.2;
                
                if (delta > 0) {
                    view2dZoom = Math.min(view2dZoom * zoomFactor, 10.0);
                } else {
                    view2dZoom = Math.max(view2dZoom / zoomFactor, 0.1);
                }
                
                updateZoomDisplay();
                    render2DView();
                // // console.log(`🔍 Mouse wheel zoom: ${view2dZoom.toFixed(1)}x`);
            });
            
            // Add pan/move support
            canvas2d.addEventListener('mousedown', startPan2D);
            canvas2d.addEventListener('mousemove', pan2D);
            canvas2d.addEventListener('mouseup', endPan2D);
            canvas2d.addEventListener('mouseleave', endPan2D); // End pan if mouse leaves canvas
        }

        function createMatrices3D() {
            const aspect = canvas3d.width / canvas3d.height;
            
            // Standard camera settings for all functions
            const fov = 30 * Math.PI / 180;
            const near = 0.1;
            const far = 200.0;
            
            // Camera position - function-specific distances
            const isFullscreen = document.getElementById('view3d-container').classList.contains('fullscreen');
            let distance;
            
            if (currentFunction === 'himmelblau') {
                // Himmelblau: larger scale, needs closer camera
                distance = isFullscreen ? -25 * zoom : -20 * zoom;
            } else if (currentFunction === 'rosenbrock') {
                // Rosenbrock: very small scale, needs to see full panorama
                distance = isFullscreen ? -35 * zoom : -25 * zoom;
            } else if (currentFunction === 'booth') {
                // Booth: medium scale, standard distance
                distance = isFullscreen ? -40 * zoom : -30 * zoom;
            } else {
                // Other functions: default distance
                distance = isFullscreen ? -40 * zoom : -30 * zoom;
            }
            
            const cameraPos = [0, 0, distance];
            const targetPos = [0, 0, 0];

            // Projection matrix
            const projectionMatrix = mat4.create();
            mat4.perspective(projectionMatrix, fov, aspect, near, far);

            // Model view matrix
            const modelViewMatrix = mat4.create();
            
            // Standard orbit controls for all functions
            mat4.translate(modelViewMatrix, modelViewMatrix, cameraPos);
            mat4.rotateX(modelViewMatrix, modelViewMatrix, rotationX);
            mat4.rotateY(modelViewMatrix, modelViewMatrix, rotationY);

            // Normal matrix (3x3)
            const normalMatrix = mat3.create();
            mat3.fromMat4(normalMatrix, modelViewMatrix);
            mat3.invert(normalMatrix, normalMatrix);
            mat3.transpose(normalMatrix, normalMatrix);

            return { projectionMatrix, modelViewMatrix, normalMatrix };
        }

        function createMatrices2D() {
            // Use same setup as 3D but with different view angle
            const aspect = canvas2d.width / canvas2d.height;
            const fov = 30 * Math.PI / 180;
            const near = 0.1;
            const far = 200.0;

            // Projection matrix
            const projectionMatrix = mat4.create();
            mat4.perspective(projectionMatrix, fov, aspect, near, far);

            // Model view matrix - top-down view (looking down at z=0 plane)
            const modelViewMatrix = mat4.create();
            mat4.translate(modelViewMatrix, modelViewMatrix, [0, 0, -15]); // Fixed distance
            mat4.rotateX(modelViewMatrix, modelViewMatrix, -Math.PI/2); // Look straight down
            // No Y rotation to keep it simple

            // Normal matrix (3x3)
            const normalMatrix = mat3.create();
            mat3.fromMat4(normalMatrix, modelViewMatrix);
            mat3.invert(normalMatrix, normalMatrix);
            mat3.transpose(normalMatrix, normalMatrix);

            return { projectionMatrix, modelViewMatrix, normalMatrix };
        }

        function render() {
            if (autoRotate) {
                rotationY += 0.005;
            }

            // Render 3D view
            render3DView();
            
            // Render 2D view
            render2DView();

            requestAnimationFrame(render);
        }

        function render3DView() {
            if (!gl3d || !program3d) {
                // // console.log('❌ WebGL not initialized properly');
                return;
            }
            
            // Clear 3D canvas
            gl3d.clearColor(0.95, 0.95, 0.98, 1.0);
            gl3d.clear(gl3d.COLOR_BUFFER_BIT | gl3d.DEPTH_BUFFER_BIT);

            gl3d.useProgram(program3d);

            const { projectionMatrix, modelViewMatrix, normalMatrix } = createMatrices3D();

            // Set uniforms
            const projectionLocation = gl3d.getUniformLocation(program3d, 'projectionMatrix');
            const modelViewLocation = gl3d.getUniformLocation(program3d, 'modelViewMatrix');
            const normalMatrixLocation = gl3d.getUniformLocation(program3d, 'normalMatrix');
            const debugModeLocation = gl3d.getUniformLocation(program3d, 'debugMode');
            const enhancedLightingLocation = gl3d.getUniformLocation(program3d, 'enhancedLighting');
            const wireframeModeLocation = gl3d.getUniformLocation(program3d, 'wireframeMode');
            const contourModeLocation = gl3d.getUniformLocation(program3d, 'contourMode');
            const minimaModeLocation = gl3d.getUniformLocation(program3d, 'minimaMode');
            const optimizerModeLocation = gl3d.getUniformLocation(program3d, 'optimizerMode');
            const optimizerColorLocation = gl3d.getUniformLocation(program3d, 'optimizerColor');
            const minHeightLocation = gl3d.getUniformLocation(program3d, 'minHeight');
            const maxHeightLocation = gl3d.getUniformLocation(program3d, 'maxHeight');
            
            gl3d.uniformMatrix4fv(projectionLocation, false, projectionMatrix);
            gl3d.uniformMatrix4fv(modelViewLocation, false, modelViewMatrix);
            gl3d.uniformMatrix3fv(normalMatrixLocation, false, normalMatrix);
            gl3d.uniform1i(debugModeLocation, debugMode);
            gl3d.uniform1i(enhancedLightingLocation, enhancedLighting);
            gl3d.uniform1i(wireframeModeLocation, wireframeMode);
            gl3d.uniform1i(contourModeLocation, false);
            
            // Calculate and set min/max height for color mapping
            const func = functions[currentFunction];
            const range = 8;
            let minHeight = Infinity;
            let maxHeight = -Infinity;
            
            // Sample function values to find min/max
            for (let x = -range; x <= range; x += 0.5) {
                for (let y = -range; y <= range; y += 0.5) {
                    const z = func.func(x, y) * func.scale;
                    minHeight = Math.min(minHeight, z);
                    maxHeight = Math.max(maxHeight, z);
                }
            }
            
            // Ensure we have valid range
            if (minHeight === Infinity) minHeight = 0;
            if (maxHeight === -Infinity) maxHeight = 1;
            if (minHeight === maxHeight) maxHeight = minHeight + 1;
            
            // // console.log(`Height range: ${minHeight.toFixed(3)} to ${maxHeight.toFixed(3)}`);
            
            gl3d.uniform1f(minHeightLocation, minHeight);
            gl3d.uniform1f(maxHeightLocation, maxHeight);
            gl3d.uniform1i(minimaModeLocation, false);

            // Set up vertex attributes
            const positionLocation = gl3d.getAttribLocation(program3d, 'position');
            const normalLocation = gl3d.getAttribLocation(program3d, 'normal');
            const colorLocation = gl3d.getAttribLocation(program3d, 'color');
            gl3d.enableVertexAttribArray(positionLocation);
            gl3d.enableVertexAttribArray(normalLocation);
            gl3d.enableVertexAttribArray(colorLocation);

            // Draw surface
            if (wireframeMode) {
                gl3d.bindBuffer(gl3d.ARRAY_BUFFER, program3d.wireframeVertexBuffer);
                gl3d.vertexAttribPointer(positionLocation, 3, gl3d.FLOAT, false, 0, 0);
                gl3d.bindBuffer(gl3d.ARRAY_BUFFER, program3d.wireframeNormalBuffer);
                gl3d.vertexAttribPointer(normalLocation, 3, gl3d.FLOAT, false, 0, 0);
                gl3d.bindBuffer(gl3d.ARRAY_BUFFER, program3d.wireframeColorBuffer);
                gl3d.vertexAttribPointer(colorLocation, 3, gl3d.FLOAT, false, 0, 0);
                gl3d.drawArrays(gl3d.LINES, 0, program3d.wireframeNumVertices);
            } else {
                gl3d.bindBuffer(gl3d.ARRAY_BUFFER, program3d.vertexBuffer);
                gl3d.vertexAttribPointer(positionLocation, 3, gl3d.FLOAT, false, 0, 0);
                gl3d.bindBuffer(gl3d.ARRAY_BUFFER, program3d.normalBuffer);
                gl3d.vertexAttribPointer(normalLocation, 3, gl3d.FLOAT, false, 0, 0);
                gl3d.bindBuffer(gl3d.ARRAY_BUFFER, program3d.colorBuffer);
                gl3d.vertexAttribPointer(colorLocation, 3, gl3d.FLOAT, false, 0, 0);
                gl3d.drawArrays(gl3d.TRIANGLES, 0, program3d.numVertices);
            }

            // Draw minima markers
            gl3d.uniform1i(minimaModeLocation, true);
            gl3d.bindBuffer(gl3d.ARRAY_BUFFER, program3d.minimaVertexBuffer);
            gl3d.vertexAttribPointer(positionLocation, 3, gl3d.FLOAT, false, 0, 0);
            gl3d.bindBuffer(gl3d.ARRAY_BUFFER, program3d.minimaNormalBuffer);
            gl3d.vertexAttribPointer(normalLocation, 3, gl3d.FLOAT, false, 0, 0);
            gl3d.drawArrays(gl3d.TRIANGLES, 0, program3d.minimaNumVertices);
            gl3d.uniform1i(minimaModeLocation, false);

            // Draw SGD path and current position on 3D surface
            drawAllOptimizerPaths3D(gl3d, program3d, positionLocation, normalLocation, contourModeLocation, minimaModeLocation, optimizerModeLocation, optimizerColorLocation);
        }

        function render2DView() {
            if (!ctx2d || !canvas2d) {
                // // console.log('❌ Canvas 2D not initialized properly');
                return;
            }
            
            // Clear 2D canvas
            ctx2d.clearRect(0, 0, canvas2d.width, canvas2d.height);
            
            // Set background
            ctx2d.fillStyle = '#f8f9fa';
            ctx2d.fillRect(0, 0, canvas2d.width, canvas2d.height);

            // Draw contour lines using Canvas 2D with colors
            // // console.log('🔍 Debug: window.contourData =', window.contourData ? window.contourData.length : 'undefined');
            if (window.contourData && window.contourData.length > 0) {
                // // console.log('✅ Drawing colored contours with', window.contourData.length, 'points');
                ctx2d.lineWidth = 1.0; // Slightly thicker lines for better visibility

                const centerX = canvas2d.width / 2;
                const centerY = canvas2d.height / 2;
                const scale = getZoomedScale(); // Use zoomed scale

                // Draw each line segment with its own color
                for (let i = 0; i < window.contourData.length; i += 6) {
                    const colorIndex = i / 6; // Each line segment has a color
                    const color = window.contourColors && window.contourColors[colorIndex] ? 
                        window.contourColors[colorIndex] : '#4a90e2';
                    
                    ctx2d.strokeStyle = color;
                    ctx2d.beginPath();
                    
                    const x1 = centerX + (window.contourData[i] - view2dCenterX) * scale;
                    const y1 = centerY - (window.contourData[i + 1] - view2dCenterY) * scale; // Flip Y axis
                    const x2 = centerX + (window.contourData[i + 3] - view2dCenterX) * scale;
                    const y2 = centerY - (window.contourData[i + 4] - view2dCenterY) * scale; // Flip Y axis

                    ctx2d.moveTo(x1, y1);
                    ctx2d.lineTo(x2, y2);
                ctx2d.stroke();
                }

                // Draw minima markers
                let minima = [];
                if (currentFunction === 'himmelblau') {
                    minima = [[3, 2], [-2.805118, 3.131312], [-3.779310, -3.283186], [3.584428, -1.848126]]; // 4 minima
                } else if (currentFunction === 'rosenbrock') {
                    minima = [[1, 1]]; // 1 minimum
                } else if (currentFunction === 'quadratic') {
                    minima = [[0, 0]]; // 1 minimum
                } else if (currentFunction === 'booth') {
                    minima = [[1, 3]]; // 1 minimum
                }
                ctx2d.fillStyle = '#e74c3c';
                for (const [x, y] of minima) {
                    const px = centerX + (x - view2dCenterX) * scale;
                    const py = centerY - (y - view2dCenterY) * scale; // Flip Y axis
                    ctx2d.beginPath();
                    ctx2d.arc(px, py, 4, 0, 2 * Math.PI);
                    ctx2d.fill();
                }
            }

            // Draw SGD path and current position on 2D view
            drawAllOptimizerPaths2D();
            
            // Draw starting position marker
            drawStartMarker2D();

            // Debug: log every 2 seconds
            if (Math.floor(Date.now() / 1000) % 2 === 0) {
                // // console.log(`2D View: Drawing contours with Canvas 2D`);
            }
        }

        // Draw SGD path on 3D view
        // Convert hex color to RGB array
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [
                parseInt(result[1], 16) / 255,
                parseInt(result[2], 16) / 255,
                parseInt(result[3], 16) / 255
            ] : [1, 0, 0]; // Default red if parsing fails
        }

        // Generate thick line geometry using triangles
        function generateThickLineVertices(points, thickness = 0.1) {
            const vertices = [];
            const normals = [];
            
            if (points.length < 2) return { vertices, normals };
            
            for (let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i + 1];
                
                // Calculate direction vector
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const dz = p2.z - p1.z;
                
                // Calculate perpendicular vector (normal to the line)
                const length = Math.sqrt(dx * dx + dy * dy);
                if (length > 0) {
                    const perpX = -dy / length * thickness;
                    const perpY = dx / length * thickness;
                    
                    // Create two triangles for thick line segment
                    // Triangle 1: p1-left, p1-right, p2-left
                    vertices.push(
                        p1.x + perpX, p1.y + perpY, p1.z,
                        p1.x - perpX, p1.y - perpY, p1.z,
                        p2.x + perpX, p2.y + perpY, p2.z
                    );
                    
                    // Triangle 2: p1-right, p2-right, p2-left
                    vertices.push(
                        p1.x - perpX, p1.y - perpY, p1.z,
                        p2.x - perpX, p2.y - perpY, p2.z,
                        p2.x + perpX, p2.y + perpY, p2.z
                    );
                    
                    // Add normals pointing up
                    for (let j = 0; j < 6; j++) {
                        normals.push(0, 0, 1);
                    }
                }
            }
            
            return { vertices, normals };
        }

        function drawAllOptimizerPaths3D(gl, program, positionLocation, normalLocation, contourModeLocation, minimaModeLocation, optimizerModeLocation, optimizerColorLocation) {
            // Draw each enabled optimizer's path
            Object.keys(optimizers).forEach(optimizerName => {
                const optimizer = optimizers[optimizerName];
                if (!optimizer.enabled || !optimizer.path || optimizer.path.length === 0) return;

                // Create thick path using triangles
                const thickLineData = generateThickLineVertices(optimizer.path, 0.05);

                if (thickLineData.vertices.length > 0) {
                    // Create buffer for thick path
                const pathBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, pathBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(thickLineData.vertices), gl.STATIC_DRAW);

                const pathNormalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, pathNormalBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(thickLineData.normals), gl.STATIC_DRAW);

                    // Draw thick path with optimizer color
                    const rgbColor = hexToRgb(optimizer.color);
                    gl.uniform1i(optimizerModeLocation, true);
                    gl.uniform3f(optimizerColorLocation, rgbColor[0], rgbColor[1], rgbColor[2]);
                gl.bindBuffer(gl.ARRAY_BUFFER, pathBuffer);
                gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, pathNormalBuffer);
                gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, false, 0, 0);
                    gl.drawArrays(gl.TRIANGLES, 0, thickLineData.vertices.length / 3);
                    gl.uniform1i(optimizerModeLocation, false);

                // Clean up
                gl.deleteBuffer(pathBuffer);
                gl.deleteBuffer(pathNormalBuffer);
            }

                // Draw starting position as a small colored sphere
                if (optimizer.path.length > 0) {
                    const startPoint = optimizer.path[0];
                const startVertices = [];
                const startNormals = [];
                const radius = 0.15;
                const segments = 8;

                for (let i = 0; i < segments; i++) {
                    const angle1 = (i * 2 * Math.PI) / segments;
                    const angle2 = ((i + 1) * 2 * Math.PI) / segments;
                    
                    startVertices.push(startPoint.x, startPoint.y, startPoint.z);
                    startVertices.push(
                        startPoint.x + radius * Math.cos(angle1),
                        startPoint.y + radius * Math.sin(angle1),
                        startPoint.z
                    );
                    startVertices.push(
                        startPoint.x + radius * Math.cos(angle2),
                        startPoint.y + radius * Math.sin(angle2),
                        startPoint.z
                    );
                    
                    startNormals.push(0, 0, 1);
                    startNormals.push(0, 0, 1);
                    startNormals.push(0, 0, 1);
                }

                const startBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, startBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(startVertices), gl.STATIC_DRAW);

                const startNormalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, startNormalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(startNormals), gl.STATIC_DRAW);

                // Use optimizer mode for individual optimizer color (start position)
                const rgbColor = hexToRgb(optimizer.color);
                gl.uniform1i(optimizerModeLocation, true);
                gl.uniform3f(optimizerColorLocation, rgbColor[0], rgbColor[1], rgbColor[2]);
                gl.bindBuffer(gl.ARRAY_BUFFER, startBuffer);
                gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, startNormalBuffer);
                gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, false, 0, 0);
                gl.drawArrays(gl.TRIANGLES, 0, startVertices.length / 3);
                gl.uniform1i(optimizerModeLocation, false);

                gl.deleteBuffer(startBuffer);
                gl.deleteBuffer(startNormalBuffer);
            }

                // Draw current position as a larger colored sphere
                if (optimizer.position) {
                const currentVertices = [];
                const currentNormals = [];
                const radius = 0.25;
                const segments = 8;

                for (let i = 0; i < segments; i++) {
                    const angle1 = (i * 2 * Math.PI) / segments;
                    const angle2 = ((i + 1) * 2 * Math.PI) / segments;
                    
                        currentVertices.push(optimizer.position.x, optimizer.position.y, optimizer.position.z);
                    currentVertices.push(
                            optimizer.position.x + radius * Math.cos(angle1),
                            optimizer.position.y + radius * Math.sin(angle1),
                            optimizer.position.z
                    );
                    currentVertices.push(
                            optimizer.position.x + radius * Math.cos(angle2),
                            optimizer.position.y + radius * Math.sin(angle2),
                            optimizer.position.z
                    );
                    
                    currentNormals.push(0, 0, 1);
                    currentNormals.push(0, 0, 1);
                    currentNormals.push(0, 0, 1);
                }

                const currentBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, currentBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(currentVertices), gl.STATIC_DRAW);

                const currentNormalBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, currentNormalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(currentNormals), gl.STATIC_DRAW);

                    // Use optimizer mode for current position with individual optimizer color
                    const rgbColor = hexToRgb(optimizer.color);
                    gl.uniform1i(optimizerModeLocation, true);
                    gl.uniform3f(optimizerColorLocation, rgbColor[0], rgbColor[1], rgbColor[2]);
                gl.bindBuffer(gl.ARRAY_BUFFER, currentBuffer);
                gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);
                gl.bindBuffer(gl.ARRAY_BUFFER, currentNormalBuffer);
                gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, false, 0, 0);
                gl.drawArrays(gl.TRIANGLES, 0, currentVertices.length / 3);
                    gl.uniform1i(optimizerModeLocation, false);

                gl.deleteBuffer(currentBuffer);
                gl.deleteBuffer(currentNormalBuffer);
            }
            });
        }

        // Draw all optimizer paths on 2D view
        function drawAllOptimizerPaths2D() {
            const centerX = canvas2d.width / 2;
            const centerY = canvas2d.height / 2;
            const scale = getZoomedScale();
            
            // Draw each enabled optimizer's path
            Object.keys(optimizers).forEach(optimizerName => {
                const optimizer = optimizers[optimizerName];
                if (!optimizer.enabled) return;
                
                // Set optimizer color
                ctx2d.strokeStyle = optimizer.color;
                ctx2d.fillStyle = optimizer.color;

                // Draw path as connected lines (only if path exists)
                if (optimizer.path.length > 0) {
                ctx2d.lineWidth = 2;
                ctx2d.beginPath();

                    for (let i = 0; i < optimizer.path.length; i++) {
                        const point = optimizer.path[i];
                        const x = centerX + (point.x - view2dCenterX) * scale;
                        const y = centerY - (point.y - view2dCenterY) * scale; // Flip Y axis

                    if (i === 0) {
                        ctx2d.moveTo(x, y);
                    } else {
                        ctx2d.lineTo(x, y);
                    }
                }
                ctx2d.stroke();
            }

            // Always draw current position and gradient vector (even if no path yet)
                if (optimizer.position) {
                    const x = centerX + (optimizer.position.x - view2dCenterX) * scale;
                    const y = centerY - (optimizer.position.y - view2dCenterY) * scale;
                    
                    // Draw current position as a larger circle
                ctx2d.beginPath();
                ctx2d.arc(x, y, 6, 0, 2 * Math.PI);
                ctx2d.fill();

                    // Draw gradient arrow only if enabled
                    if (window.showGradientVectors !== false) { // Default to true if not set
                        const gradient = functions[currentFunction].gradient(optimizer.position.x, optimizer.position.y);
                if (gradient) {
                    const gradScale = 0.4; // Scale for gradient arrow visibility
                            const gradEndX = optimizer.position.x + gradient.x * gradScale;
                            const gradEndY = optimizer.position.y + gradient.y * gradScale;
                    
                    const gradCanvasX = centerX + gradEndX * scale;
                    const gradCanvasY = centerY - gradEndY * scale; // Flip Y axis
                    
                    // Draw gradient arrow (pointing up the hill)
                            ctx2d.strokeStyle = optimizer.color;
                    ctx2d.lineWidth = 2;
                    ctx2d.beginPath();
                    ctx2d.moveTo(x, y);
                    ctx2d.lineTo(gradCanvasX, gradCanvasY);
                    ctx2d.stroke();

                    // Draw arrowhead
                    const angle = Math.atan2(gradCanvasY - y, gradCanvasX - x);
                    const arrowSize = 6;
                    ctx2d.beginPath();
                    ctx2d.moveTo(gradCanvasX, gradCanvasY);
                    ctx2d.lineTo(
                        gradCanvasX - arrowSize * Math.cos(angle - Math.PI / 6),
                        gradCanvasY - arrowSize * Math.sin(angle - Math.PI / 6)
                    );
                    ctx2d.moveTo(gradCanvasX, gradCanvasY);
                    ctx2d.lineTo(
                        gradCanvasX - arrowSize * Math.cos(angle + Math.PI / 6),
                        gradCanvasY - arrowSize * Math.sin(angle + Math.PI / 6)
                    );
                    ctx2d.stroke();
                }
            }
                }
            });
        }

        // Draw starting position marker on 2D view
        function drawStartMarker2D() {
            const centerX = canvas2d.width / 2;
            const centerY = canvas2d.height / 2;
            const scale = getZoomedScale();

            // Draw starting position marker for each enabled optimizer
            Object.keys(optimizers).forEach(optimizerName => {
                const optimizer = optimizers[optimizerName];
                if (!optimizer.enabled || !optimizer.path || optimizer.path.length === 0) return;
                
                const startPoint = optimizer.path[0];
                const x = centerX + (startPoint.x - view2dCenterX) * scale;
                const y = centerY - (startPoint.y - view2dCenterY) * scale; // Flip Y axis

                ctx2d.fillStyle = optimizer.color;
            ctx2d.beginPath();
                ctx2d.arc(x, y, 3, 0, 2 * Math.PI);
            ctx2d.fill();
            
            // Add a small border
            ctx2d.strokeStyle = '#2c3e50'; // Dark border
            ctx2d.lineWidth = 1;
            ctx2d.stroke();
            });
        }

        // Control functions
        function toggleWireframe() {
            wireframeMode = !wireframeMode;
            // // console.log('Wireframe mode:', wireframeMode ? 'ON' : 'OFF');
        }

        function resetView() {
            rotationX = -0.2;
            rotationY = 0;
            zoom = 1;
            // // console.log('View reset');
        }

        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            // // console.log('Auto rotate:', autoRotate ? 'ON' : 'OFF');
        }

        function toggleDebugMode() {
            debugMode = !debugMode;
            // // console.log('Debug mode:', debugMode ? 'ON (showing normals)' : 'OFF (normal lighting)');
        }

        function toggleFaceCulling() {
            faceCullingEnabled = !faceCullingEnabled;
            if (faceCullingEnabled) {
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.BACK);
                // // console.log('Face culling: ON (back faces culled)');
            } else {
                gl.disable(gl.CULL_FACE);
                // // console.log('Face culling: OFF (all faces visible)');
            }
        }

        function toggleLightingMode() {
            enhancedLighting = !enhancedLighting;
            // // console.log('Lighting mode:', enhancedLighting ? 'Enhanced (multi-light)' : 'Simple (very bright)');
        }

        function toggleContours() {
            showContours = !showContours;
            // // console.log('Contours:', showContours ? 'ON (showing parameter space contours)' : 'OFF');
        }


        // Simple mat3 implementation
        const mat3 = {
            create: function() {
                const out = new Float32Array(9);
                out[0] = 1; out[4] = 1; out[8] = 1;
                return out;
            },
            fromMat4: function(out, a) {
                out[0] = a[0]; out[1] = a[1]; out[2] = a[2];
                out[3] = a[4]; out[4] = a[5]; out[5] = a[6];
                out[6] = a[8]; out[7] = a[9]; out[8] = a[10];
            },
            invert: function(out, a) {
                const a00 = a[0], a01 = a[1], a02 = a[2];
                const a10 = a[3], a11 = a[4], a12 = a[5];
                const a20 = a[6], a21 = a[7], a22 = a[8];

                const b01 = a22 * a11 - a12 * a21;
                const b11 = -a22 * a01 + a12 * a21;
                const b21 = a21 * a01 - a11 * a21;

                let det = a00 * b01 + a10 * b11 + a20 * b21;

                if (!det) {
                    return null;
                }
                det = 1.0 / det;

                out[0] = b01 * det;
                out[1] = b11 * det;
                out[2] = b21 * det;
                out[3] = (-a22 * a10 + a12 * a20) * det;
                out[4] = (a22 * a00 - a12 * a20) * det;
                out[5] = (-a21 * a00 + a11 * a20) * det;
                out[6] = (a10 * a21 - a11 * a20) * det;
                out[7] = (-a00 * a21 + a01 * a20) * det;
                out[8] = (a00 * a11 - a01 * a10) * det;

                return out;
            },
            transpose: function(out, a) {
                out[0] = a[0]; out[1] = a[3]; out[2] = a[6];
                out[3] = a[1]; out[4] = a[4]; out[5] = a[7];
                out[6] = a[2]; out[7] = a[5]; out[8] = a[8];
            }
        };

        // Simple mat4 implementation
        const mat4 = {
            create: function() {
                const out = new Float32Array(16);
                out[0] = 1; out[5] = 1; out[10] = 1; out[15] = 1;
                return out;
            },
            perspective: function(out, fovy, aspect, near, far) {
                const f = 1.0 / Math.tan(fovy / 2);
                const nf = 1 / (near - far);
                
                out[0] = f / aspect; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = (far + near) * nf; out[11] = -1;
                out[12] = 0; out[13] = 0; out[14] = (2 * far * near) * nf; out[15] = 0;
            },
            ortho: function(out, left, right, bottom, top, near, far) {
                const lr = 1 / (left - right);
                const bt = 1 / (bottom - top);
                const nf = 1 / (near - far);
                
                out[0] = -2 * lr; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = -2 * bt; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = 2 * nf; out[11] = 0;
                out[12] = (left + right) * lr; out[13] = (top + bottom) * bt; out[14] = (far + near) * nf; out[15] = 1;
            },
            translate: function(out, a, v) {
                const x = v[0], y = v[1], z = v[2];
                
                out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
                out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
                out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
                out[12] = a[12] + a[0] * x + a[4] * y + a[8] * z;
                out[13] = a[13] + a[1] * x + a[5] * y + a[9] * z;
                out[14] = a[14] + a[2] * x + a[6] * y + a[10] * z;
                out[15] = a[15] + a[3] * x + a[7] * y + a[11] * z;
            },
            rotateX: function(out, a, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a10 = a[4];
                const a11 = a[5];
                const a12 = a[6];
                const a13 = a[7];
                const a20 = a[8];
                const a21 = a[9];
                const a22 = a[10];
                const a23 = a[11];
                
                out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
                out[4] = a10 * c + a20 * s; out[5] = a11 * c + a21 * s; out[6] = a12 * c + a22 * s; out[7] = a13 * c + a23 * s;
                out[8] = a20 * c - a10 * s; out[9] = a21 * c - a11 * s; out[10] = a22 * c - a12 * s; out[11] = a23 * c - a13 * s;
                out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
            },
            rotateY: function(out, a, rad) {
                const s = Math.sin(rad);
                const c = Math.cos(rad);
                const a00 = a[0];
                const a01 = a[1];
                const a02 = a[2];
                const a03 = a[3];
                const a20 = a[8];
                const a21 = a[9];
                const a22 = a[10];
                const a23 = a[11];
                
                out[0] = a00 * c - a20 * s; out[1] = a01 * c - a21 * s; out[2] = a02 * c - a22 * s; out[3] = a03 * c - a23 * s;
                out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
                out[8] = a00 * s + a20 * c; out[9] = a01 * s + a21 * c; out[10] = a02 * s + a22 * c; out[11] = a03 * s + a23 * c;
                out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
            }
        };

        // Handle ESC key to exit fullscreen
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                const fullscreenView = document.querySelector('.view-container.fullscreen');
                if (fullscreenView) {
                    const viewType = fullscreenView.id.replace('view', '').replace('-container', '');
                    toggleFullscreen(viewType);
                }
            }
        });

        // Initialize when page loads
        window.addEventListener('load', () => {
            // // console.log('🚀 Page loaded, initializing Multi-Function WebGL...');
            const success = initWebGL();
            if (success) {
                // // console.log('🎉 Multi-Function WebGL initialized successfully!');
            } else {
                console.error('💥 Multi-Function WebGL initialization failed!');
            }
        });
    </script>
    
    <!-- Optimizer Formulas Section -->
    <div class="formulas-section">
        <div class="formulas-header">
            <h2>📐 Optimizer Mathematical Formulas</h2>
        </div>
        <div class="formulas-grid">
            <!-- SGD -->
            <div class="formula-panel">
                <div class="formula-title">SGD (Stochastic Gradient Descent)</div>
                <div class="formula-content">
                    <div class="formula-main">θ<sub>t+1</sub> = θ<sub>t</sub> - α∇f(θ<sub>t</sub>)</div>
                    <div class="formula-desc">Where <strong>α</strong> is the learning rate and <strong>∇f(θ<sub>t</sub>)</strong> is the gradient</div>
                </div>
            </div>
            
            <!-- Momentum -->
            <div class="formula-panel">
                <div class="formula-title">Momentum</div>
                <div class="formula-content">
                    <div class="formula-main">v<sub>t</sub> = βv<sub>t-1</sub> + ∇f(θ<sub>t</sub>)</div>
                    <div class="formula-main">θ<sub>t+1</sub> = θ<sub>t</sub> - αv<sub>t</sub></div>
                    <div class="formula-desc">Where <strong>β</strong> is momentum coefficient (typically 0.9) and <strong>v<sub>t</sub></strong> is velocity</div>
                </div>
            </div>
            
            <!-- AdaGrad -->
            <div class="formula-panel">
                <div class="formula-title">AdaGrad</div>
                <div class="formula-content">
                    <div class="formula-main">G<sub>t</sub> = G<sub>t-1</sub> + ∇f(θ<sub>t</sub>)<sup>2</sup></div>
                    <div class="formula-main">θ<sub>t+1</sub> = θ<sub>t</sub> - α∇f(θ<sub>t</sub>)/√(G<sub>t</sub> + ε)</div>
                    <div class="formula-desc">Where <strong>ε</strong> is small constant (1e-8) and <strong>G<sub>t</sub></strong> accumulates squared gradients</div>
                </div>
            </div>
            
            <!-- Adam -->
            <div class="formula-panel">
                <div class="formula-title">Adam (Adaptive Moment Estimation)</div>
                <div class="formula-content">
                    <div class="formula-main">m<sub>t</sub> = β₁m<sub>t-1</sub> + (1-β₁)∇f(θ<sub>t</sub>)</div>
                    <div class="formula-main">v<sub>t</sub> = β₂v<sub>t-1</sub> + (1-β₂)∇f(θ<sub>t</sub>)<sup>2</sup></div>
                    <div class="formula-main">m̂<sub>t</sub> = m<sub>t</sub>/(1-β₁<sup>t</sup>)</div>
                    <div class="formula-main">v̂<sub>t</sub> = v<sub>t</sub>/(1-β₂<sup>t</sup>)</div>
                    <div class="formula-main">θ<sub>t+1</sub> = θ<sub>t</sub> - α·m̂<sub>t</sub>/(√v̂<sub>t</sub> + ε)</div>
                    <div class="formula-desc">Where <strong>β₁=0.9</strong>, <strong>β₂=0.999</strong>, <strong>m̂<sub>t</sub></strong> and <strong>v̂<sub>t</sub></strong> are bias-corrected estimates</div>
                </div>
            </div>
            
            <!-- RMSprop -->
            <div class="formula-panel">
                <div class="formula-title">RMSprop (Root Mean Square Propagation)</div>
                <div class="formula-content">
                    <div class="formula-main">E[g²]<sub>t</sub> = ρE[g²]<sub>t-1</sub> + (1-ρ)∇f(θ<sub>t</sub>)<sup>2</sup></div>
                    <div class="formula-main">θ<sub>t+1</sub> = θ<sub>t</sub> - α∇f(θ<sub>t</sub>)/√(E[g²]<sub>t</sub> + ε)</div>
                    <div class="formula-desc">Where <strong>ρ</strong> is decay rate (typically 0.9) and <strong>E[g²]<sub>t</sub></strong> is exponentially weighted average</div>
                </div>
            </div>
            
            <!-- AdaDelta -->
            <div class="formula-panel">
                <div class="formula-title">AdaDelta (Adaptive Learning Rate)</div>
                <div class="formula-content">
                    <div class="formula-main">E[g²]<sub>t</sub> = ρE[g²]<sub>t-1</sub> + (1-ρ)∇f(θ<sub>t</sub>)<sup>2</sup></div>
                    <div class="formula-main">Δθ<sub>t</sub> = -√(E[Δθ²]<sub>t-1</sub> + ε)/√(E[g²]<sub>t</sub> + ε) · ∇f(θ<sub>t</sub>)</div>
                    <div class="formula-main">E[Δθ²]<sub>t</sub> = ρE[Δθ²]<sub>t-1</sub> + (1-ρ)Δθ<sub>t</sub><sup>2</sup></div>
                    <div class="formula-main">θ<sub>t+1</sub> = θ<sub>t</sub> + Δθ<sub>t</sub></div>
                    <div class="formula-desc">Where <strong>ρ</strong> is decay rate (typically 0.95), <strong>E[g²]<sub>t</sub></strong> and <strong>E[Δθ²]<sub>t</sub></strong> are running averages</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- About Section -->
    <div class="about-section">
        <div class="about-header">
            <h2>ℹ️ About</h2>
        </div>
        <div class="about-content">
            <div class="developer-info">
                <div class="developer-name">👨‍💻 Developed by Thanh-Sach LE</div>
                <div class="developer-contact">
                    📧 Email: <a href="mailto:ltsach@hcmut.edu.vn">ltsach@hcmut.edu.vn</a>
                </div>
                <div class="developer-affiliation">
                    🏛️ Ho Chi Minh City University of Technology (HCMUT) - VNUHCM
                </div>
            </div>
            <div class="project-description">
                <p>This interactive visualization tool demonstrates various optimization algorithms used in neural network training, including SGD, Momentum, AdaGrad, Adam, RMSprop, and AdaDelta. Users can compare their performance on different mathematical functions and observe detailed training dynamics.</p>
            </div>
        </div>
    </div>
    
    <style>
        .formulas-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px 20px;
            margin-top: 20px;
        }
        
        .formulas-header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .formulas-header h2 {
            margin: 0;
            font-size: 2.2em;
            font-weight: 600;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .formulas-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .formula-panel {
            background: rgba(255, 255, 255, 0.95);
            color: #2c3e50;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .formula-panel:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 35px rgba(0,0,0,0.3);
        }
        
        .formula-title {
            font-size: 1.4em;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 15px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 8px;
        }
        
        .formula-content {
            font-family: 'Courier New', monospace;
        }
        
        .formula-main {
            font-size: 1.2em;
            font-weight: 700;
            color: #2c3e50;
            margin: 12px 0;
            padding: 15px 18px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            border: 2px solid #3498db;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.2);
            font-family: 'Times New Roman', serif;
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .formula-main::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #3498db, #e74c3c, #f39c12, #9b59b6);
        }
        
        .formula-main sub {
            font-size: 0.75em;
            color: #e74c3c;
            font-weight: 600;
            background: rgba(231, 76, 60, 0.1);
            padding: 2px 4px;
            border-radius: 3px;
            margin: 0 1px;
        }
        
        .formula-main sup {
            font-size: 0.75em;
            color: #e74c3c;
            font-weight: 600;
            background: rgba(231, 76, 60, 0.1);
            padding: 2px 4px;
            border-radius: 3px;
            margin: 0 1px;
        }
        
        .formula-desc {
            font-size: 0.95em;
            color: #34495e;
            margin-top: 12px;
            font-style: italic;
            background: rgba(52, 152, 219, 0.05);
            padding: 10px 15px;
            border-radius: 8px;
            border-left: 4px solid #3498db;
            line-height: 1.5;
        }
        
        .formula-desc strong {
            color: #2c3e50;
            font-weight: 600;
        }

        /* About Section Styles */
        .about-section {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 40px 20px;
            margin-top: 20px;
        }

        .about-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .about-header h2 {
            margin: 0;
            font-size: 2.2em;
            font-weight: 600;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .about-content {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1.2fr 1.8fr;
            gap: 40px;
            align-items: start;
        }

        .developer-info {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .developer-name {
            font-size: 1.2em;
            font-weight: 700;
            margin-bottom: 12px;
            color: #ecf0f1;
        }

        .developer-contact {
            font-size: 1.0em;
            margin-bottom: 10px;
            color: #bdc3c7;
        }

        .developer-contact a {
            color: #3498db;
            text-decoration: none;
            font-weight: 600;
            transition: color 0.3s ease;
        }

        .developer-contact a:hover {
            color: #2980b9;
            text-decoration: underline;
        }

        .developer-affiliation {
            font-size: 0.95em;
            color: #95a5a6;
            font-style: italic;
        }

        .project-description {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 25px;
            border-left: 4px solid #3498db;
        }

        .project-description p {
            font-size: 1.1em;
            line-height: 1.7;
            margin: 0;
            color: #ecf0f1;
            text-align: justify;
        }

        @media (max-width: 768px) {
            .about-content {
                grid-template-columns: 1fr;
                gap: 25px;
            }
            
            .about-header h2 {
                font-size: 1.8em;
            }
            
            .developer-name {
                font-size: 1.2em;
            }
            
            .project-description p {
                font-size: 1.0em;
                text-align: left;
            }
        }

        /* Calculation Section Styles */
        .calculation-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            margin: 20px auto;
            max-width: 1600px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .calculation-header {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px 20px;
            transition: all 0.3s ease;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .calculation-header:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .calculation-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: white;
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            flex: 1;
        }

        .calculation-controls {
            display: flex;
            gap: 8px;
            margin-left: 15px;
        }

        .calc-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: white;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 32px;
            height: 32px;
        }

        .calc-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        .calc-btn:active {
            transform: translateY(0);
            background: rgba(255, 255, 255, 0.4);
        }

        .calculation-label {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .calculation-count {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 500;
        }

        .calculation-content {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            transition: all 0.3s ease;
            max-height: 1000px;
            overflow: hidden;
        }

        .calculation-content.collapsed {
            max-height: 0;
            padding: 0 20px;
        }

        .calculation-display {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 10px;
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
        }

        .calc-step {
            margin-bottom: 20px;
        }

        .calc-step-title {
            font-size: 1.2rem;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 15px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 8px;
        }

        .calc-content {
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            color: #2c3e50;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .calc-step-item {
            margin: 8px 0;
            padding: 8px 12px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 6px;
            border-left: 4px solid #3498db;
        }

        .calc-formula {
            color: #e74c3c;
            font-weight: 600;
            margin: 5px 0;
        }

        .calc-value {
            color: #27ae60;
            font-weight: 500;
        }

        .calc-optimizer {
            color: #8e44ad;
            font-weight: 600;
        }

        /* Chart Section Styles */
            display: block;
            margin: 0 auto;
        }

        /* Comparison Charts Section Styles */
        .comparison-charts-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
            border-radius: 15px;
            margin: 20px auto;
            max-width: 1600px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            transition: all 0.3s ease;
        }

        /* Force gradient background */
        div.comparison-charts-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
        }

        .comparison-charts-header {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px 20px;
            transition: all 0.3s ease;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .comparison-charts-header:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .comparison-charts-title {
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: white;
            font-weight: 600;
            font-size: 1.1rem;
            cursor: pointer;
            flex: 1;
        }

        .comparison-charts-label {
            color: white;
            font-weight: 600;
            font-size: 1.1rem;
        }

        .comparison-charts-count {
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
            font-size: 0.95rem;
        }

        .comparison-charts-section .toggle-icon {
            color: white;
        }

        .comparison-charts-controls {
            display: flex;
            gap: 8px;
            margin-left: 15px;
        }

        .charts-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            color: white;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 32px;
            height: 32px;
        }

        .charts-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }

        .comparison-charts-content {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            transition: all 0.3s ease;
            max-height: 1000px;
            overflow: hidden;
        }

        .comparison-charts-content.collapsed {
            max-height: 0;
            padding: 0 20px;
        }

        .charts-display {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .chart-section {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid #dee2e6;
        }

        .chart-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
        }

        .chart-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #loss-chart, #gradient-magnitude-chart {
            border: 1px solid #dee2e6;
            border-radius: 8px;
            background: white;
            display: block;
        }

        .chart-legend {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-top: 5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9rem;
            color: #2c3e50;
        }

        .legend-color {
            width: 16px;
            height: 3px;
            border-radius: 2px;
            background: #ccc;
        }

        .legend-label {
            font-weight: 500;
        }

        /* Pseudocode Section Styles */
        .pseudocode-section {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            border: 1px solid #dee2e6;
        }

        .pseudocode-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
        }

        .pseudocode-content {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .pseudocode-content pre {
            margin: 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            color: #2c3e50;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .pseudocode-content code {
            background: none;
            padding: 0;
            color: inherit;
        }

        .pseudocode-content .variable {
            font-weight: bold;
            color: #1976d2;
        }
    </style>
    
    <script>
        // Initialize SGD as default logging optimizer when page loads
        document.addEventListener('DOMContentLoaded', function() {
            updateCalculationCount();
            updatePseudocode(); // Load default pseudocode
            setupMouseCoordinates(); // Setup mouse coordinate tracking
        });
        
        // Setup mouse coordinate tracking for 2D canvas
        function setupMouseCoordinates() {
            const canvas2d = document.getElementById('canvas2d');
            const coordsDisplay = document.getElementById('mouse-coordinates');
            
            if (!canvas2d || !coordsDisplay) {
                console.error('Canvas2d or coordinates display not found');
                return;
            }
            
            // Add mousemove event listener
            canvas2d.addEventListener('mousemove', function(e) {
                const rect = canvas2d.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Convert canvas coordinates to parameter space coordinates
                const centerX = canvas2d.width / 2;
                const centerY = canvas2d.height / 2;
                const scale = getZoomedScale();
                
                const paramX = (x - centerX) / scale + view2dCenterX;
                const paramY = -(y - centerY) / scale + view2dCenterY; // Flip Y axis
                
                // Update coordinates display with 2 decimal places
                coordsDisplay.textContent = `(${paramX.toFixed(2)}, ${paramY.toFixed(2)})`;
            });
            
            // Hide coordinates when mouse leaves canvas
            canvas2d.addEventListener('mouseleave', function() {
                coordsDisplay.textContent = '(0.00, 0.00)';
            });
        }
    </script>
</body>
</html>
